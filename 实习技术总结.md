# 

1. 基于C++20设计无栈协程Coroutine，支持返回任意类型的结果，通过设计字段管理父子协程关系，方便协程的嵌套与调用
1. 搭建协程调度框架Loop，统一管理协程的生命周期和资源，集成小根堆定时器、任务处理等异步操作，提高了系统的健壮性和稳定性
1. 实现采用多维调度队列的线程池，公平调度执行队列，提供模板接口co_async以同步编码的方式异步执行任意函数并返回任意类型结果
1. 使用 FrameWork 框架实现项目模块化设计及按优先级动态加载，便于添加、移除或替换模块，提高了项目的灵活性、可扩展性和开发效率
1. 使用QT搭建仿真界面，根据协议文档封装不同类型消息、实现串口与TCP通信。通过Manger对协议模块集中管理，保持界面与业务逻辑的分离
1. 使用CMake构建整个项目，使用Git进行版本控制



#  具体问题

1. **基于C++20设计无栈协程Coroutine，支持返回任意类型的结果，通过设计字段管理父子协程关系，方便协程的嵌套与调用**

>进程：一段程序的执行过程，资源分配和调度的基本单位，有其独立地址空间，互相之间不发生干扰 ，为了只执行程序，不需要独立的内存，I/O等资源，而是共享已有资源，于是产生了线程。
>
>线程：轻量级进程，资源调度的最小单位，共享父进程地址空间和资源，其调度和进程一样要切换到内核态，切换需要开销，因此线程过多，可能不会提高效率
>
>协程：一种轻量级的用户态线程  
>
>优势： 1 协程是非抢占式调度，由开发者自行控制程序切换时机，而不是像进程和线程那样把控制权交给操作系统 ，没有线程、进程切换的时间和资源开销 
>
>​	     2 协程是运行在线程之上的，同一个线程在同一时刻只能运行一个协程，在同一个线程中，协程是串行的，不会产生线程资源的竞争,不需要多线程的		锁机制
>
>​             3 可以通过同步的编码方式，实现异步操作。传统异步操作方式有两种，1个是多线程+回调函数，通过条件变量或者`join`确保异步操作完成，2另外		一个就需要内核的API，在内部通过中断+回调来实现。
>
>如何实现嵌套？
>
>

2. **搭建协程调度框架Loop，统一管理协程的生命周期和资源，集成小根堆定时器、任务处理等异步操作，提高了系统的健壮性和稳定性**

>如何实现异步？
>
>

3. **实现采用多维调度队列的线程池，对每个执行队列公平调度。提供模板接口co_async以同步编码的方式异步执行任意函数并返回任意类型结果**

>多维调度队列原理及优势
>
>通过executer管理，线程池个数
>
>线程池关闭，未执行的函数如何处理？
>
>在项目中如何使用？
>
>```cpp
>static inline auto coro_async_direct(F f, Args... args) -> Coroutine<decltype(std::apply(std::move(f), std::make_tuple(std::move(args)...)))>
>{
>    static WorkerQueue queue;
>    co_return co_await co_async(&queue, std::move(f), std::move(args)...);
>}
>```
>

4. **使用 FrameWork 框架实现项目模块化设计及按优先级动态加载，便于添加、移除或替换模块，提高了项目的灵活性、可扩展性和开发效率**

>**模块化设计**：将项目的每个模块编译为独立的动态库，使代码更易于维护和更新。各个模块可以独立开发和调试，降低了耦合度。
>
>**动态加载**：通过 FrameWork 框架在运行时动态加载指定的动态库，可以根据实际需要加载所需的模块，优化内存和资源使用。这种方式支持热插拔，使得应用程序可以在不中断运行的情况下更新或更换模块。
>
>**按优先级执行**：在主函数中按优先级顺序执行各个模块，确保关键任务或依赖项先行处理，提高了程序的启动效率和运行稳定性。
>
>**灵活性和可扩展性**：FrameWork 框架允许轻松添加、移除或替换模块，极大地提高了项目的灵活性和可扩展性。适应新的需求和变化时，只需更新或添加相关动态库，而不必重构整个项目。
>
>**简化主程序**：主程序只需负责加载和初始化动态库，无需管理各个模块的细节，实现了代码的简洁性和清晰性。
>
>**提高开发效率**：通过将不同功能模块分离，各个开发团队可以并行工作，提高了开发效率。框架的使用标准化了模块的接口和行为，减少了沟通成本和集成难度。

5. **使用QT搭建仿真界面，根据协议文档封装不同类型消息、实现串口与TCP通信。通过Manger对协议模块集中管理，保持界面与业务逻辑的分离**

> 怎么保持业务逻辑分离？
>
> tcp通信？串口通信？

6. **使用CMake构建整个项目，使用Git进行版本控制**











# 1 excuter执行器

## 1.1 线程池

### 线程池大小

```cpp
void init()
{
    uint32_t threadSize = std::thread::hardware_concurrency(); // cpu核心数  20个
    threadSize = threadSize < 4 ? 4 : threadSize;              // 保证线程池大小最小4个线程

    m_asyncWorkerExecutor = new AsyncExecutor(threadSize);
    m_syncWorkerExecutor = new SyncExecutor(threadSize);
}
```



## 1.2 接口

### push

* `co_awiat co_woker`: 将任务函数转为LoopWoker，传给excuter

* `executer->push(LoopWorker, WorkerQueue)`，将外部函数封装为指定格式，传入executer

  



# 2 FrameWork

* 加载执行文件目录下包含指定字段的dll库

```cpp
auto f = frameworkInstance(); 
frameworkInit(f, ExeUtils::getExeDirPath(), "Plugin");
```

![image-20240711172314912](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures/img/202407111723956.png)