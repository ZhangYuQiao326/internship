[学习文档1](E:\typora索引文件\c++\算法\优选算法精品课_课件.pdf)

[学习文档2](E:\typora索引文件\c++\算法\优选算法二.pdf)

[动态规划](F:\学习视频\比特就业课c++\资料\精品课课件\动态规划\动态规划.pdf)

"F:\学习视频\比特就业课c++\资料\精品课课件\动态规划"

# 腾讯

1.自我介绍

2.lru（在线ide太恶心了，不会用，导致写了二十多分钟，麻了，还得自己打样例）

3.lru还能怎么优化（面试官说得考虑线程安全。。。）

4.osi七层和tcp/ip四层

5.tcp三握四挥

6.tcp和udp的区别

7.网页输入url

8.c和c++的差别

9.引用与指针

10.new/malloc和delete/free的区别

11.内存分配的几种方式和如何进行管理

12.三大智能指针内部实现和做什么的

13.虚函数和纯虚函数的区别和内部实现

14.线性表的实现方法

15.数组和链表的区别

16.队列和栈的区别

17.二叉搜索树

18.二叉平衡树

19.二叉树的深度优先遍历

20.通过什么方式实现（递归和不递归的两种方式）

21.有个数组，找出数组中出现次数最多的（要通解，一眼哈希表）

22.死锁

23.怎么实现死锁查找器

24.自旋锁和互斥锁的区别

25.什么是临界区（不会）

26.什么是优先级反转（不会）



c++客户端，没录屏八股只记得一部分
3.12一面：
八股：
1.堆和栈
2.静态库和动态库 
3.如何保证线程安全
4.使用锁的缺点
5.创建内存有什么方式，其中的区别
6.虚函数实现原理
7.野指针和悬空指针，怎么避免
8.知道几种IO模型
9.tcp传输的内容如何加密
10.tcp滑动窗口，有什么用
算法：
1.两个升序链表，合并成一个升序/降序链表
2.一个无序链表，变成升序的 （以及如何调用第一题的方法实现）

3.13二面
八股：
1.git reset和revert
2.merge和rebase，分别适用什么情况
3.share_ptr，有什么用，怎么实现
4.如何用udp实现tcp
5.如何用tcp实现http
6.知道http2？和http1的区别
7.三种IO多路复用的区别
8.tcp黏包，怎么解决
场景题：
IO多路复用，间隔两秒按序对三个ip发请求，保持所有连接直到其中一个accept。
算法：
1.链表每隔k个元素进行翻转，如果最后不足k个保持不变
2.返回无序数组第k大的数

# 数据结构常用操作

## 1 算法

### 1.1 排序

```cpp
std::sort(vector.begin(), vector.end()); // vector需要全局的sort
list<int> lis;
lis.sort(); // 含有成员变量sort
```

### 1.2 求最大值

```cpp
#include <algorithm>

vector<int> vevv = { 2,4,5,1,9,5,6 };
auto ans = max_element(vevv.begin(), vevv.end());
if (ans != vevv.end())
{
    int lens = distance(vevv.begin(), ans); // 计算下标，两迭代器之间的距离
	cout << *ans << endl;
}
```



## 2 ACM输入

1. 先输入n表示n个数组元素，再依次输入n个元素,插入数组

   ```cpp
   int main()
   {
   	int n, a;
       cin >> n;
       vector<int> arr(n);
       
       for(int i = 0; i < n; ++i) cin >> arr[i]; 
   }
   ```

   

## 3 算法循环

1、指针同向移动，用for循环

2、指针对向移动，用while循环

| 算法       | 循环                                               | 注意                              |
| ---------- | -------------------------------------------------- | --------------------------------- |
| 分块双指针 | `for(int cur = 0; cur < nums.size(); i++)`         |                                   |
| 快慢指针   | `while(fast && fast->next)`                        | 指针相遇则有环                    |
| 对撞指针   | `while(left < right)`                              |                                   |
| 滑动窗口   | `for(int right = 0, left = 0; right < n; ++right)` |                                   |
| 朴素二分   | `while(left <= right)`                             | 闭区间有效， <=                   |
| 区间二分   | `while(left < right)`                              | 条件没有等于、mid获取需要分情况+1 |
| 快排、快查 | `while(cur < right)`                               | 当前处理位置 < right位置          |
|            |                                                    |                                   |

![image-20240731111928883](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures/img/202407311119180.png)



# 双指针

**朴素双指针：**

一个指针遍历数组，一个指针用来标记位置

解决：数组、链表删除元素



| 朴素双指针                                                   | 快慢双指针                          | 对撞双指针（要求升序）                                       |
| ------------------------------------------------------------ | ----------------------------------- | ------------------------------------------------------------ |
| 一个指针遍历（for循环挨个处理数组），一个指针标识处理好的数据最后一位 | 一个走一步，一个走两步（while循环） | 首尾指针向中间走，（while循环）                              |
| 解决：数组分块问题，2 删除数组链表元素                       | 解决：1 判断是否有环                | 解决：两数之和和第三个数比较                                 |
| 数组分两块（移动0）：非0   0                                 | 快乐数                              | [构成三角形最大个数](https://leetcode.cn/problems/valid-triangle-number/) |
| 复写0                                                        |                                     | [水桶装最多水](https://leetcode.cn/problems/container-with-most-water/) |
| 数组分三块（颜色划分、快排）：0 1 2 （三指针）               |                                     | 两数之和、三数之和、去重、返回所有值                         |

## 1 朴素双指针

1. 左指针标记已处理的下表， 右指针用于遍历数组

2. 因此，左右指针位置差1

   

----



【移动0 ， 双指针， 分两块】[leetcode](https://leetcode.cn/problems/move-zeroes/)

1. 左指针永远指向已经处理过的元素，右指针指向准备处理的元素
2. 先将左指针移动，指向准备处理的位置

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int des = -1; // 起始位置-1
        // 双指针
        for(int cur = 0; cur < nums.size(); ++cur){
            if(nums[cur] ){
                swap(nums[++des], nums[cur]);
            }

        }
    }
};
```

【删除值为tar的元素】

```cpp
int removeTar(vector<int> nums, int tar)
{
	int len = nums.size();
	if (!len) return len;

	int left = -1, right = 0;
	for (; right < len; right++)
	{
		if (nums[right] != tar)
		{
			nums[++left] = nums[right];
		}
	}
	return left + 1;
}
```



【删除重复元素，保留1位】

```cpp
int removeDuplicates(vector<int>& nums)
{
	int len = nums.size();
	if (len < 2) return len;

	int left = 0, right = 1;
	for(; right < len; ++right)
	{
		if (nums[left] != nums[right])
		{
			nums[++left] == nums[right];
			
		}
	}
	return left + 1;
}
```

【删除重复元素，全部删除】

```cpp
int removeRepeatVal(vector<int>& nums)
{
	int len = nums.size();
	if (len < 3 ) return len;

	int left = 0, right = 1;
	for (; right < len; ++right)
	{
		if (nums[left] != nums[right])
		{
			nums[++left] = nums[right];
		}
		else
		{
			while (nums[right] == nums[right + 1])
			{
				right++;
			}
			left--;
		}
		
	}
	return left + 1;
}
```



【颜色分块，三指针，分三块】[leetcode](https://leetcode.cn/problems/sort-colors/)

```cpp
// 指针在前，r指针在后，中间为待处理区class Solution {
public:
    void sortColors(vector<int>& nums) {
        int len = nums.size();
        int left = -1;
        int right = len;
        int i = 0;
        while(i < right){
            if(nums[i] == 0) swap(nums[++left], nums[i++]);
            else if(nums[i] == 1) i++;
            else swap(nums[--right], nums[i]);
        }
        
    }
};

```



【有序数组】双指针、二分查找

## 2 快慢指针

【判断是否有环】

```cpp
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if(head == NULL) return false;  // 边界

        ListNode *slow = head, *fast = head;
        while(fast && fast->next)   // fast存在，才能访问fast->next存在，才能访问fast->next->next
        {
            slow = slow->next;
            fast = fast->next->next;
            if(slow == fast) return true; // 相等则有环
        }
        return false;
    }
};
```

【返回环的入口节点】

```cpp
ListNode *detectCycle(ListNode *head) {
    // 1 判断是否有环--快慢指针
    if(head==nullptr) return nullptr;

    ListNode* slow = head, *fast = head;
    while(fast and fast->next)
    {
        slow = slow->next;
        fast = fast->next->next;
        if(slow == fast) 
        {
            // 2 fast从head重新出发，slow从相遇点出发，均每次走一格
            // 再次相遇的点即为入口
            fast = head;
            while(fast != slow)
            {
                fast = fast->next;
                slow = slow->next;
            }
            return fast;
        }
    }
    return nullptr;
}
```



## 3 对撞指针

1. 关于 `while(left <= right)`是否有等号问题
2. 需要处理 `right == left`的位置元素，则需要等号； 【非递减数组的平方】
3. 不需要处理该位置，则不要等号,【两数之和、三数之和】

-----



【两数之和--返回下标】哈希表   【两数之和--返回元素】排序对撞指针

```cpp
// 下标
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> hash;

        for(int i = 0; i < nums.size();++i)
        {
            int key = nums[i];
            hash[key] = i;
        }
        for(int i = 0; i < nums.size(); ++i)
        {
            int key = target - nums[i];
            if(hash.find(key) != hash.end())
            {
                // 找到
                if(hash[key] != i)
                {
                    // 去重
                    return {i, hash[key]};
                }
            }
        }
        return {-1, -1};
    }
};

// 元素（对撞）
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while(left < right)
        {
            int sum = nums[left] + nums[right];
            if(sum > target) right--;
            else if(sum < target) left++;
            else return {left, right};
        }
        return {-1, -1};
    }
};
```

【非递增数组的平方--对撞指针】

```cpp
// 最大值在最左边or最右边
// [-5,-3,2,2,5]
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) 
    {
        vector<int> ans;
        ans.resize(nums.size());
        int index = ans.size() - 1;

        int left = 0, right = nums.size() - 1;
        while (left <= right)
        {
            int a = nums[left] * nums[left], b = nums[right] * nums[right];
            if (a < b)
            {
                ans[index--] = b;
                right--;
            }
            else
            {
                ans[index--] = a;
                left++;
            }
        }
        return ans;
        
    }
};
```



# 滑动窗口

| 滑动窗口（同向双指针）                                       | 2                              |
| ------------------------------------------------------------ | ------------------------------ |
| 解决： 满足条件的==最短/最长==连续子串                       |                                |
| [子串值和>=tar的最短子串](https://leetcode.cn/problems/minimum-size-subarray-sum/description/) |                                |
| [子串值和>=tar的最长子串](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/) |                                |
| [无重复值最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/) | 数组模拟哈希表                 |
| [最多包含两种数的最长子串](https://leetcode.cn/problems/fruit-into-baskets/)【水果成篮】 | 哈希表                         |
| [连续相同值的最长子串](https://leetcode.cn/problems/max-consecutive-ones-iii/description/) | 反转0                          |
| [找到字符串的所有异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/)， [找到字符串的以（字符串为组合）的异位词](https://leetcode.cn/problems/minimum-window-substring/) | 哈希 + 有效词计数              |
| // 固定滑动窗口                                              |                                |
| [删除链表的倒数第n个节点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/) | 右指针先走，构建固定的滑动串口 |

* 右指针在for循环内默认一直划入
* while判断是否滑出

* 左指针移动，画出窗口

* 滑动窗口常常结合哈希表进行判断，哈希表有unordered_map、数组等

```cpp
// 右指针一直滑出
for(int right = 0, left = 0; right < n; ++right){
    // 1 执行滑入操作，影响判断条件
    ....
    while(// 2 判断条件失效){
        // 3 左指针执行滑出操作,直到条件重新满足
        .....
        left ++;
	}
	// 4 输出结果，根据情况。放在1 3 4
    return ret;
}
```

```cpp
int minSubArrayLen(int target, vector<int>& nums) {
        int len = nums.size(), sum = 0, ret = INT_MAX;
        for(int i = 0, j = 0; i < len; ++i){
            sum+=nums[i];
            while(sum >= target){
                ret = min((i - j + 1), ret);
                // 滑出
                sum-=nums[j];
                j++;

            }

        }
        return ret==INT_MAX ? 0 : ret;

    }
```

【无重复值最长字串】

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int hash[128] = {0};
        int len = 0;
        for(int left=0, right=0; right < s.size(); ++right)
        {
            int index = s[right] ;
            hash[index] ++;
            while(hash[index] > 1)
            {
                
                int indexl = s[left] ;
                hash[indexl] --;
                left ++;
            }
            len = max(len, right-left +1);
        }
        return len;
    }
};
```





# 二分查找

* 数组必须有序（非递增、非递减）
* 无论朴素二分or升级二分，判断大小时，固定tar，判断mid落在哪一个区间。

| 类型                                             | 方法     |
| ------------------------------------------------ | -------- |
| 找固定的一个位置或者==一个数==                   | 朴素二分 |
| 找==一段区间==的左右端点，区间内数一致或者不一致 | 升级二分 |

```cpp
// 朴素二分
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1; 
        while (left <= right) { // 1 当left==right，区间[left, right]依然有效，所以用 <=
            int middle = left + ((right - left) / 2);// 2 防止溢出 等同于(left + right)/2
            if (nums[middle] > target) {
<<<<<<< HEAD
                right = middle - 1; 
=======
                // 跳出区间
                right = middle - 1; // target 在左区间，所以[left, middle - 1]
>>>>>>> 7334b7b063221b0909daa899d13509c6e2e8919e
            } else if (nums[middle] < target) {
                left = middle + 1; 
            } else { 
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        
        return -1;// 未找到目标值
        return left; // 插入位置 == right + 1,  此时left > right ，right为小于target的最后一个元素
    }
};
```

------------



升级二分查找步骤：

1. 根据判断条件将数组分为两个区间：跳出区间 和 结果区间 

```cpp
1 if(arr[mid] > target)  // 划分大于小于tar两个区间
2 if(arr[mid] > arr[mid-1])  // 划分递增递减两个区间
```

2. arr数组在那一部分，则为结果区间

1. mid落在结果区间，则left（right）移动不能超过mid，落在移动区间，则left（right）跳出mid
2. 找右结果区间的左端点，将区间化为两份，若mid落在左区间，则left想跳出来，所以left = mid + 1, 落在右区间，right不能超过mid ，所以right = mid
3. 找做结果区间的右端点，将区间化为两份，若mid落在左区间，则left不能超过mid，所以left = mid，落在右区间，则right要跳出来，right = mid - 1

最终结果为 mid = left = right，判断该位置是否等于target




![image-20240312214030888](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240312214030888.png)

![image-20240312213603909](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240312213603909.png)

```cpp
// 升级二分
// 找一样的数的起始结束
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        // 边界
        if(nums.size() == 0 ) return {-1, -1};
        int left = 0, right  = nums.size() -1;;
        int begin = -1; // 保存左节点
        
        // 1 找左端点
        while(left < right){               // 1 不同点
            int mid = left + ((right - left)/2);
            if(nums[mid] < target) left = mid + 1;  // 先写跳出区间
            else right = mid; // 再写结果区间
        }
        
        // 循环结束 left = right ，若等于tar则有结果，否则无
        if(nums[left] == target)  begin = left;
        else return{-1,-1};
        // 2 找右端点
        // left从左端点出发，右端点重置
        right = nums.size() - 1;
        while(left < right){
            int mid = left + ((right - left + 1) / 2);  // 不同点 mid赋值改变
            if(nums[mid] > target) right = mid - 1;  
            else left = mid; 
        }
        // 左端点存在，则一定存在右端点
        return {begin, right};
    }
};
```



| 题目         | 类型                                                         | 题目                                                         |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
|              | ![image-20240312225421888](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240312225421888.png) | [题](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/submissions/511092837/) |
| 查找峰值元素 | ![image-20240312225536890](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240312225536890.png) | [题](https://leetcode.cn/problems/peak-index-in-a-mountain-array/description/) |
|              | ![image-20240312230757122](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240312230757122.png) | [题](https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/)   |

【山峰顶点】

```cpp
// 只查找右端点
int peakIndexInMountainArray(vector<int>& arr)
{
	int left = 0, right = arr.size() - 1;
	while (left < right)
	{
		int mid = left + (right - left + 1) / 2;
		if (arr[mid] < arr[mid - 1]) right = mid - 1;
		else left = mid;
	}
	return right;
}
```







# 前缀和

<img src="https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures/img/202408191108583.png" alt="image-20240819110825002" style="zoom: 33%;" />

步骤：

1 定义相同大小的前缀和数组dp		

2 [i,j]区间的和 = dp[j] - dp[i - 1]

3 某位置的前缀和 = vec[该位置] + dp[前面位置]

| 类型                                                         | 算法                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 解决：求已知的连续一段数组的和或积                           |                                                              |
| 一维前缀和                                                   | 位置i表示位置i之前的所有和、表示加上i以及之前的所有和        |
| 二维前缀和                                                   |                                                              |
| 求数组中心点坐标                                             | 前缀和 + 后缀和                                              |
| [求和为k的连数数组的个数](https://leetcode.cn/problems/subarray-sums-divisible-by-k/) | 使用变量保存前缀和                                           |
| [和被k整除的连续数组个数](https://leetcode.cn/problems/subarray-sums-divisible-by-k/) | 同余定理                                                     |
| 解决：求某元素的左右两段区域的和或积                         | 1. 不计算当前i在前缀内   2  需要设置f[0] 和 g[n-1] 位0或1    |
| 一维前缀和 +  一维后缀和                                     | 后缀数组从后往前填充值，g[i] = g[i+1] +vec[i]; [题目](https://leetcode.cn/problems/find-pivot-index/submissions/511534400/) |
| 一维前缀积 +  一维后缀积                                     | [leetcode](https://leetcode.cn/problems/product-of-array-except-self/) |



## 1 一维前缀和/后缀和

* 求数组内某一段区间的和
* 时间复杂度 O(n)

* 设置 n+1 大小的数组，将0下表位置空下，进而简化边界情况

```cpp
#include <iostream>
using namespace std;
#include <vector>
int main() {
    int n, q;
    cin >> n >> q;
    vector<int> arr (n+1);
    for(int i = 1; i <=n ;++i)
    {
        cin >> arr[i];
    }

    // 1 dp数组
    vector<long long > dp (n+1);
    for(int i = 1; i <= n; ++i)
    {
        dp[i] = arr[i] + dp[i-1];
    }

    // 2 相减求前缀和
    int l, r;
    while(q--)
    {
        cin >> l >> r;
        cout << dp[r] - dp[l-1] << endl;
    }
}
// 64 位输出请用 printf("%lld")
```

【求数组中心点坐标】

```cpp
class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        int n = nums.size();
        if (!n) return -1;
        vector<int>dp(n);
        auto dp2 = dp;

        dp[0] = nums[0];
        for (int i = 1; i < n; ++i)
        {
            dp[i] = dp[i - 1] + nums[i];
        }
        // 后缀和, 从倒数第二个元素开始计算
        dp2[n - 1] = nums[n - 1];
        for (int i = n - 2; i >= 0; --i)
        {
            dp2[i] = dp2[i + 1] + nums[i];
        }

        int ans = -1;
        for (int i = 0; i < n; ++i)
        {
            if (dp[i] == dp2[i]) return i;
        }
        return ans;
    }
};
```

【和为k的连续数组个数】

```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int,int> hash; // <[0,i-1]的前缀和， 个数>
        int sum = 0, ret = 0;
        hash[0] = 1;  // 和为0的数组有1个
        for(auto e: nums){
            sum+=e; // 前缀和
            if(hash.count(sum - k)) ret+=hash[sum-k]; //统计个数
            hash[sum]++;
        }
        return ret;

    }
};
```

【和被k整除的连续数组个数】

```cpp
// // 同余定理（b-a）%n == 0 则 b%n == a%n
class Solution {
public:
    int subarraysDivByK(vector<int>& nums, int k) {
        int n = nums.size();
        int sum = 0, ret = 0;
        unordered_map<int, int> hash;
        hash[0] = 1;

        for (auto x : nums)
        {
            sum += x;
            int yu = (sum % k+ k) % k;  // 注意负数取余操作
            if (hash.count(yu)) ret += hash[yu];  // [0,i-1]区间同余的数组个数
            hash[yu]++;
        }
        return ret;
    }
};
```





## 2 二维前缀和

[求一块矩阵的和](https://www.nowcoder.com/practice/99eb8040d116414ea3296467ce81cbbc?tpId=230&tqId=2023819&ru=/exam/oj&qru=/ta/dynamic-programming/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D196)

![image-20240313211626949](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240313211626949.png)

![image-20240819140014513](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures/img/202408191400606.png)

```cpp
#include <iostream>
using namespace std;
#include <vector>

int main() {
    int n, m, q;
    cin >> n >> m >>q;
    vector<vector<int>> vec(n+1, vector<int>(m + 1));
    for(int i = 1; i <= n; ++i){
        for (int j = 1; j <=m; ++j){
            cin >> vec[i][j];
        }
    }

    // 1 创建前缀和矩阵
    vector<vector<long long>> dp(n+1, vector<long long>(m + 1));
    for(int i = 1; i <= n; ++i){
        for (int j = 1; j <=m; ++j){
            dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + vec[i][j];
        }
    }

    // 2 使用
    int x1, y1, x2, y2;
    while(q--){
        cin >> x1 >> y1 >> x2 >> y2;
        cout << dp[x2][y2] - dp[x1-1][y2] - dp[x2][y1-1] + dp[x1-1][y1-1] << endl;
    }
    return 0;

}

```

## 3 前缀积 + 后缀积

![image-20240313223746626](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240313223746626.png)



```cpp
// 8-19
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int len = nums.size();
        vector<int>ans(len);
        vector<int> dp(len);
        auto dp2 = dp;

        // 以i为结尾的数组之前、之后的乘积(不包含i元素)
        // 前缀积
        dp[0] = 1;
        for (int i = 1; i < len; ++i)
        {
            dp[i] = dp[i - 1] * nums[i - 1];
        }
        // 后缀积
        dp2[len - 1] = 1;
        for (int i = len - 2; i >= 0; --i)
        {
            dp2[i] = dp2[i + 1] * nums[i + 1];
        }

        for (int i = 0; i < len; ++i)
        {
            ans[i] = dp[i] * dp2[i];
        }
        return ans;
    }
};
```





# 位运算

![image-20240314224516512](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240314224516512.png)

| 需求                   | 操作                                          |
| ---------------------- | --------------------------------------------- |
| &                      | 有0为0                                        |
| \|                     | 有1为1                                        |
| ^异或                  | 同为0，异为1，无进位相加   （1+0 = 0  1+1=0） |
| 判断数n的x位为1？0     | `(n>>x) & 1  ` 与上1                          |
| 将数n的x位变为1        | `n |=(1<<x) `  或上1                          |
| 将数n的x位变为0        | n &=(0 << x)  与上0                           |
| 提取数n二进制最右边的1 | `n & (-n)`                                    |
| 删除数n二进制最右边的1 | `n & (n -1)`                                  |
| ^的运算规律（消消乐）  | n ^ n =0 ; n^0=0   ;a^ b ^ c = a^(b ^ c)      |
|                        |                                               |

【判断字符串字符是否出现次数唯一】

```cpp
// 2024-3-14
class Solution {
public:
    bool isUnique(string astr) {
        if(astr.size() > 26) return false;
        int bit = 0;
        for(auto e : astr){
            // 存放在第x位置
            int x = e - 'a';
            // 判断x位置是0还是1
            if((bit >> x) & 1 == 1) return false;
            else {
                // 加入位图
                // 修改x位置为1
                bit |= (1<<x);
            }
            
        }
        return true;

    }
};
```

【找丢失的数字】

```cpp
// 3-14
// 通过异或来消消乐
// 即nums的数和【0，n】的所有数字异或，消消乐，剩余消失的数字
// 根据分配率，可以先异或nums，再异或[0,n]
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int bit = 0;
        for(auto e: nums) bit^=e;
        for(int i = 0; i <=nums.size(); ++i) bit^=i;
        return bit;

    }
};
```

【两数相加】

```cpp
class Solution {
public:
    int getSum(int a, int b) {
        while(b != 0){
            // 无进位相加
            int sum = a ^ b;
            // 求进位
            int car = (a & b) << 1;
            a = sum;
            b = car;
        }
        return a;

    }
};
```

![image-20240730232809418](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240730232809418.png)

# 快排

> 三段快排，适合于含有重复值的vec排序
>
> 排序后[l, left], [left+1, right-1], [right, r]，中间段为重复值

* 利用颜色分块的思想
* 根据随机值选取key
* 根据key分为三段区间
* 递归调用排序

```cpp
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        //  1 设随机数种子
        srand(time(NULL));
        qsort(nums,0, nums.size()-1);
        return nums;

    } 
    void qsort(vector<int>&nums, int l, int r){         // 1 传入引用
        if(l>=r) return;                                  // 2 边界判断
        int key = getKey(nums, l, r);
        // 分三块，比key小的放左边，大的放右边
        int i = l, left = l - 1, right = r+1;           // 3 快排主体（根）
        while(i<right){
            if(nums[i] < key) swap(nums[++left], nums[i++]); // （先移动指针，再交换）
            else if(nums[i] == key) ++i;
            else swap(nums[--right], nums[i]); // 4 i不自增

        }
        // [l left][left+1, right-1][right,r]
        qsort(nums,l,left);              // 5 递归（左右）
        qsort(nums,right,r);

    }
    int getKey(vector<int>&nums, int l, int r){
        // 通过随机数设置
        int ra = rand();
        return nums[ra % (r - l + 1) + l];  // 随机数 % nums长度 + left
    }
};

```

## Topk问题

| 问题          | 算法(堆排序、快速选择算法) |
| ------------- | -------------------------- |
| 返回第K大元素 |                            |
| 返回第K小元素 |                            |
| 返回前K大元素 |                            |
| 返回前K小元素 |                            |

* 快速选择算法

![image-20240322121650568](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240322121650568.png)

```cpp
// topk
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        srand(time(NULL));
        return qchoose(nums, 0, nums.size()-1, k);
    }
    
    // 快速选择
    int qchoose(vector<int>& nums, int l, int r, int k){
        if(r ==l ) return nums[l];
        int key = getKey(nums, l, r);
        // 1 快排（先移动指针，再交换）
        int i = l, left = l - 1, right = r + 1;
        while( i < right){
            if(nums[i] < key) swap(nums[++left], nums[i++]);
            else if(nums[i] == key) i++;
            else swap(nums[--right], nums[i]);
        }

		// 一、返回第k小
        // 2 选择性递归[l, left][left + 1, right -1][right, r]
        int leftLen = left - l + 1
        int midLen = right - 1 - (left - 1) + 1;
        if(leftLen >= k) return qchoose(nums, l, left, k); // k小在左侧
        else if(c + b >= k ) return key; // 在中间，中间值均为key
        else return qchoose(nums, right, r, k - a -b); // k小在右侧
        
        // // 一、返回第k大
        // 2 选择性递归[l, left][left + 1, right -1][right, r]
        int rightLen = r - right + 1
        int midLen = right - 1 - (left - 1) + 1;
        if(rightLen >= k) return qchoose(nums, l, left, k); // k大在右侧
        else if(c + b >= k ) return key; // 在中间，中间值均为key
        else return qchoose(nums, l, left, k - a -b); // k小在左侧
        
    }
    int getKey(vector<int>&nums, int l, int r){
        return nums[rand() % (right - left + 1) + left];
    }
};
```

* 堆排序解决topk

```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        priority_queue<int, vector<int>, greater<int>> minheap;
        // 堆中先构造k个元素
        int i = 0;
        for(; i < k; ++i){
            minheap.push(nums[i]);  // 最小的元素在上边
        }
        
        // 将k后的元素与堆中最小值进行替换
        // 最后保证小根堆中是最大的k个元素，堆顶是第k大
        for(i; i < nums.size(); ++i){
            if(nums[i] > minheap.top()){
                minheap.pop();
                minheap.push(nums[i]);
            }
        }

        return minheap.top();
    }
};
```

* 前k个元素

```cpp
class Solution {
public:
    vector<int> smallestK(vector<int>& arr, int k) {
        srand(time(NULL));
        int len = arr.size();
        qSortChoose(arr, 0, len-1, k);
        // 前k小
        return {arr.begin(), arr.begin() + k};
        // 前k大
        return {arr.begin() + arr.size() - k, arr.end()}
    }
    void qSortChoose(vector<int>& arr, int l, int r, int k){
        if(r <= l) return;
        int key = getKey(arr, l, r);

        // 三个指针
        int i = l, left = l - 1, right = r + 1;
        while(i < right){
            if(arr[i] < key) swap(arr[++left],arr[i++]);
            else if(arr[i] == key) i++;
            else swap(arr[i], arr[--right]);
        }

        // 一、前k小
        // 判断递归 [l, left][left+1, right-1][right,r]
        int a = left - l + 1;
        int b = right - 1 - left;
        if(a >= k) qSortChoose(arr, l, left, k); // 左区间寻找
        if( a + b >= k ) return ;
        else qSortChoose(arr,right, r, k - a - b );
        
        // 二、前k大
        int rightLen = r - right + 1
        int midLen = right - 1 - (left - 1) + 1;
        if(rightLen >= k) return qchoose(nums, l, left, k); // k大在右侧
        else if(c + b >= k ) return ; // 在中间，中间值均为key
        else return qchoose(nums, l, left, k - a -b); // k小在左侧

    }
    int getKey(vector<int>&arr, int left, int right){
        return arr[rand() % (right - left + 1) + left];
    }
};
```

# 归并排序

* 快排相当于树的前序遍历，处理根左右
* 归并排序相当于树的后序遍历，处理左右根
* 流程：
  1. 根据中间节点分为两个部分，两个部分分别归并排序（左右）
  2. 排序完成后合并操作，保存在tmp容器中（根）
  3. 将tmp数据迁移到原nums中

```cpp
//3-22
// 归并排序
class Solution {
    vector<int> tmp;
public:
    vector<int> sortArray(vector<int>& nums) {
        tmp.resize(nums.size());
        merageSort(nums, 0, nums.size() -1);
        return nums;

    }
    void merageSort(vector<int>& nums, int l, int r){
        if(r <= l ) return;  // 判断边界
        // 1 关键key
        int mid = (r + l) >> 1;
        // 2 左右两端分开排序
        merageSort(nums, l, mid);
        merageSort(nums, mid + 1, r);

        // 3 合并到tmp
        int cur1 = l, cur2 =mid+1, i=0;
        while(cur1 <= mid && cur2 <= r) {
            tmp[i++] = nums[cur1] <= nums[cur2] ? nums[cur1++] : nums[cur2++];
        }
        // 没有合并完的继续
        while(cur1 <= mid) tmp[i++] = nums[cur1++];
        while(cur2 <= r) tmp[i++] = nums[cur2++];

        // 4 tmp迁移到nums
        for(int i = l;i <= r; i++){
            nums[i] = tmp[i - l];
        }


    }
};

```

# 哈希

![image-20240822135709670](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures/img/202408221357864.png)

# 基本算术

## 求和

--- 位运算

```cpp
class Solution {
public:
    int getSum(int a, int b) {
        while(b != 0){
            // 无进位相加
            int sum = a ^ b;
            // 求进位
            int car = (a & b) << 1;
            a = sum;
            b = car;
        }
        return a;

    }
};
```



## 求积

--- 位运算



## 求幂

--- 递归--快速幂

```cpp
// n>=0
double pow(double x, int n){
    // 出口
    if(n == 0) return 1;
    
    // 子问题
    double tmp = pow(x, n / 2);
    return n % 2 == 0 ? tmp * tmp : tmp * tmp * x;
}

// n < > 0 且 n非常大
double myPow(double x, int n)
{
    return n > 0 ? pow(x. (long long)n) : 1 / pow(x, -(long long)n);
}
double pow(double x, long long n)
{
    if(n == 0) return 1;
    
    double tmp = pow(x, n / 2);
    return n % 2 == 0 ? tmp * tmp : tmp * tmp * x;
}
```

## 求平方根

```cpp
// 朴素二分
// 暴力：依次遍历1-x的所有元素，计算其平方
int mySqrt(int x) {
	if (x <= 1) return x;
	int left = 1, right = x / 2;
	while (left <= right)
	{
		int mid = left + (right - left) / 2;
		if ((long long)mid * mid > x) right = mid - 1;
		else if (mid * mid < x) left = left + 1;
		else return mid;
	}
	return right;
}
```



# 递归

1. 递归两种类型：链表递归、二叉树递归

   | 类型       | 操作                         | 虚节点                   |
   | ---------- | ---------------------------- | ------------------------ |
   | 链表递归   | 真实节点与递归虚节点之间操作 | 子递归的返回值节点       |
   | 二叉树递归 | 根节点与左右虚子树节点操作   | 左右子树递归的返回值节点 |

2. 递归带有返回值

   * 递归出口需要返回（边界情况）
   * 递归体需要返回

3. 做题步骤：
   * 设计函数头【返回值 + 传入参数】
   * 找递归出口 【边界情况】
   * 递归体【虚实节点之间操作】

## 1 链表递归

| 题目                                                         | 递归子问题（某次递归具体的操作）               | 出口                     |
| ------------------------------------------------------------ | ---------------------------------------------- | ------------------------ |
| [汉诺塔](https://leetcode.cn/problems/hanota-lcci/submissions/515342701/) | 将A柱上的N个盘子借助B放到C上                   | A上盘子直接放到C上       |
| [合并有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/) | 合并链表，找到头节点，链接上其余其余节点       | 某条链为空，则返回另一条 |
| [反转链表](https://leetcode.cn/problems/reverse-linked-list/description/) | 将第一个后面的节点全部逆置后，连接上第一个节点 | 保证至少有两个节点       |
| [两两反转链表](https://leetcode.cn/problems/swap-nodes-in-pairs/) | 将前两个后面的互相反，再和前两个链接           | 最后一个不动             |
| [k一组反转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/description/) |                                                |                          |
| [快速幂](https://leetcode.cn/problems/powx-n/)               |                                                |                          |

【汉诺塔】

<img src="https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240322220303724.png" alt="image-20240322220303724" style="zoom:67%;" />

```cpp
class Solution
{
public:
     void hanota(vector<int>& a, vector<int>& b, vector<int>& c)
     {
        dfs(a, b, c, a.size());
     }
     void dfs(vector<int>& a, vector<int>& b, vector<int>& c, int n)
     {
         // 出口
        if(n == 1)
        {
            c.push_back(a.back());
            a.pop_back();
            return;
        }
         // 具体部分子问题
        dfs(a, c, b, n - 1);
        c.push_back(a.back());
        a.pop_back();
        dfs(b, a, c, n - 1);
     }
};
```

【合并有序链表】

<img src="https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240322220409068.png" alt="image-20240322220409068" style="zoom:67%;" />

```cpp
class Solution
{
public:
     ListNode* mergeTwoLists(ListNode* l1, ListNode* l2)
     {
         // 出口
         if(l1 == nullptr) return l2;
         if(l2 == nullptr) return l1;
         
         // 子问题
         if(l1->val <= l2->val)
             {
             	l1->next = mergeTwoLists(l1->next, l2);
             	return l1;
             }
         else
         {
         	l2->next = mergeTwoLists(l1, l2->next);
         	return l2;
         }
     }
};

```

【反转链表】

<img src="https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240322220505550.png" alt="image-20240322220505550" style="zoom:50%;" />

```cpp
class Solution
{
public:
     ListNode* reverseList(ListNode* head) 
     {
         // 出口 --至少两个节点
         if(head == nullptr || head->next == nullptr) return head;
         
         // 子问题
         ListNode* newHead = reverseList(head->next);
         head->next->next = head;
         head->next = nullptr;
         return newHead;
     }
};

```



【两两反转】

<img src="https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240322220724085.png" alt="image-20240322220724085" style="zoom:50%;" />

```cpp
ListNode* swapPairs(ListNode* head) {
    // 出口 --保证至少有两个节点
    if(head==nullptr or head->next == nullptr) return head;
    
    // 先反转前面的一组节点
    ListNode* newhead = head->next;
    ListNode* lastNoede = newhead->next;
    newhead->next = head;
    
    // 连接后部分节点
    head->next = swapPairs(lastNoede);
    return newhead;

}
```

【k一组翻转链表】

``` cpp
ListNode* reverseKGroup(ListNode* head, int k) {
    // 递归出口--至少保证有k个节点
    ListNode* lastN = head;
    for(int i = 0; i < k; ++i)
    {
        if(lastN==nullptr) return head;
        lastN = lastN->next;
    }

    // 满足k个节点，lastN指向第k+1个节点
    // 反转[haed, lastN-1]个节点
    ListNode* preN = nullptr;
    ListNode* curN = head;
    ListNode* nextN = nullptr;

    while(curN != lastN)
    {
        nextN = curN->next;
        curN->next = preN;
        preN = curN;
        curN = nextN;
    }
	// 连接后部分节点
    head -> next = reverseKGroup(lastN, k);
    return preN;
}
```



【快速幂】

<img src="https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240323100052169.png" alt="image-20240323100052169" style="zoom:33%;" />



```cpp
// n < > 0 且 n非常大
double myPow(double x, int n)
{
    return n > 0 ? pow(x. (long long)n) : 1 / pow(x, -(long long)n);
}
double pow(double x, long long n)
{
    if(n == 0) return 1;
    
    double tmp = pow(x, n / 2);
    return n % 2 == 0 ? tmp * tmp : tmp * tmp * x;
}
```





## 2 二叉树深搜

核心：理解为 根节点+左右孩子节点之间的操作

1. 找到合适的深搜方式：前序遍历、中序遍历、后序遍历
2. 对左右子树使用递归，处理子问题
3. 对根进行具体的操作
4. 递归的出口一般是叶子节点

| 题目                                                         | 解析                                   |
| ------------------------------------------------------------ | -------------------------------------- |
| // 函数体中判断：某个节点                                    |                                        |
| [计算bool二叉树的值](https://leetcode.cn/problems/evaluate-boolean-binary-tree/) | root树是true还是false，返回bool        |
| [根节点到叶子节点路径数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/description/) | root树的根节点到叶子节点的路径数字和   |
| [二叉树剪枝](https://leetcode.cn/problems/binary-tree-pruning/submissions/515533783/) | root树是不是要剪掉，剪掉return nullptr |
| [找二叉搜索树中的第k小](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/) | (全局变量) 返回中序遍历的第k个元素     |
| [判断是否为二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/) | root树是否为搜索二叉树 （全局变量）    |
|                                                              |                                        |



## 3 回溯

https://www.cnblogs.com/three-fighter/p/15269387.html

* 解决排列、组合、路径搜索问题

1. 回溯方式：
   * 借助全局变量
   * 借助函数形参

| 题目                                                         | 解析                       |
| ------------------------------------------------------------ | -------------------------- |
| [二叉树到叶子节点所有路径](https://leetcode.cn/problems/binary-tree-paths/) | 使用==局部变量==，还原现场 |



# 树

## 1 层序遍历

| 题目                                          | 解析                                 |
| --------------------------------------------- | ------------------------------------ |
| 【查】层序遍历                                | 队列                                 |
| 倒序层次遍历、右视图、层平均值、N叉数层次遍历 |                                      |
| 二叉树最大深度、最小深度                      | 最小深度：根节点到最近叶子节点的距离 |

【二叉树最小深度】

```cpp
int minDepth(TreeNode* root) {
    if(!root) return 0;
    int depth = 0;

    queue<TreeNode*> q;
    q.push(root);
    while(!q.empty())
    {
        depth++;
        int len = q.size();
        for(int i = 0; i < len; i++)
        {
            TreeNode* cur = q.front();
            q.pop();
             if(cur->left) q.push(cur->left);
             if(cur->right) q.push(cur->right);
             if(!cur->left and !cur->right) return depth;
        }
    }
    return depth;
}
```

## 2 递归深搜

1. 函数体：找到合适dfs顺序，对子树递归（
   * 直接对子树递归   
   * 在root内对树递归
2. 递归出口：
   * `if(!root) return root`
   * `if(!root->next) return root`

| 题目                                                         | 解析                           | 函数头              |
| ------------------------------------------------------------ | ------------------------------ | ------------------- |
| 查找二叉树的节点                                             | 深搜查找                       |                     |
| 翻转二叉树                                                   | 前序遍历 + 交换左右子树        | root                |
| 判断对称二叉树                                               | 前序遍历 + 比较左右子树        | 新函数(left, right) |
| 求二叉树节点个数                                             | 后续深搜                       | root                |
| 二叉树和                                                     | 求root为根节点的数和           |                     |
| 二叉树左叶子节点和                                           | 求root为根节点的左叶子节点数和 |                     |
| [合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/) |                                |                     |
| [计算bool二叉树的值](https://leetcode.cn/problems/evaluate-boolean-binary-tree/description/) | （直接）后续遍历               |                     |
| [去除val为0的子树](https://leetcode.cn/problems/binary-tree-pruning/) | （在树内）后续遍历 + 剪枝      |                     |
| [二叉树最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/) | 两种方法                       |                     |
|                                                              |                                |                     |

【查找二叉树节点】

```cpp
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if(!root) return nullptr;

        if(root->val == val) return root;
        auto left = searchBST(root->left, val);
        if(left) return left;

        return searchBST(root->right, val);
    }
};
```



【翻转二叉树】

```cpp
TreeNode* invertTree(TreeNode* root) {
    if(!root) return root;

    swap(root->left, root->right);
    invertTree(root->left);
    invertTree(root->right);

    return root;
}
```

【判断对称二叉树】

```cpp
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(!root) return true;
        return cpt(root->left, root->right);
    }
    
    bool cpt(TreeNode*left, TreeNode* right)
    {
        if(!left && !right) return true;
        if(!left || !right) return false;
        
        bool l = cpt(left->left, right->right);
        bool r = cpt(left->right, right->left);
        if(l && r && left->val == right->val) return true;
        else return false;

    }
};
```

【二叉树结点个数】

```cpp
int countNodes(TreeNode* root) {
        
    if(!root) return 0;

    int l = countNodes(root->left);
    int r = countNodes(root->right);
    return 1 + l + r;
}
```

【二叉树和】

```cpp
class Solution {
public:
    int sumOfLeaves(TreeNode* root) {
        if(!root) return 0;
        return sumOfLeaves(root->left) + sumOfLeaves(root->right) + root-val;
    }
};
```

【合并二叉树】

```cpp
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if(!root1) return root2;
        if(!root2) return root1;

        root1->val += root2->val;  // 合并根
        root1->left = mergeTrees(root1->left, root2->left);  // 合并左子树
        root1->right = mergeTrees(root1->right, root2->right); // 合并右子树

        return root1;
    }
};
```



【二叉树左叶子节点和】

```cpp
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if(!root) return 0;

        // 左节点存在，且是叶子节点，则判断为左叶子节点
        if(root->left and !root->left->left and !root->left->right) 
        {
            return root->left->val + sumOfLeftLeaves(root->right);
        }
        return sumOfLeftLeaves(root->left) + sumOfLeftLeaves(root->right);

    }
};
```



【计算bool二叉树值】

![image-20240710234736425](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240710234736425.png)

```cpp
class Solution {
public:
    bool evaluateTree(TreeNode* root) 
    {
        
        if(root->left == nullptr) return root -> val == 0 ? false : true;
        
        bool left = evaluateTree(root->left);
        bool right = evaluateTree(root->right);
        return root -> val == 2? left | right : left & right;
        
    }
};
```



【去除val为0的子树】

![image-20240710235732091](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240710235732091.png)

```cpp
class Solution {
public:
    TreeNode* pruneTree(TreeNode* root) {
        
        if(root == nullptr) return root;
        root -> left = pruneTree(root->left);
        root -> right = pruneTree(root->right);
        if(root ->left == nullptr && root ->right == nullptr && root->val == 0)
        {
            delete root;
            root = nullptr;
        }
        return root;
    }
};
```

【根节点到叶节点路径】

```cpp
class Solution {
public:
    vector<string> ans;
    vector<string> binaryTreePaths(TreeNode* root) {
        string path = "";
        dfs(root, path);
        return ans;

    }
    // 前序遍历 + 形参保存现场
    void dfs(TreeNode* root, string path)
    {
        if(root == nullptr) return;
        path += to_string(root->val);
        // 遇到叶子节点，保存路径
        if(root->left == nullptr && root->right==nullptr)
        {
            ans.push_back(path);
        }
        else
        {
            path += "->";
        }
        if(root->left) dfs(root->left, path);
        if(root->right) dfs(root->right, path);
    }
};
```



【二叉树最近公共祖先】

```cpp
class Solution {
public:
    TreeNode *ans = nullptr; // 全局变量，保存结果
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root) return nullptr;

        dfs(root, p->val, q->val);
        return ans;
        
    }
    // 以root为根节点的树中，含有p或者q的个数
    // 二叉树中元素均不同，因此，当个数为2时候，记录root节点
    int dfs(TreeNode* root, int p, int q)
    {
        if(!root) return 0;
        
        int num = (root->val == p || root->val == q) ? 1 : 0;

        int left = dfs(root->left, p, q);
        int right = dfs(root->right, p, q);

        if((num + left + right) == 2) 
        {
            ans = root;
            return 0; // 终止递归，返回上层递归，避免结果覆盖，设为0，则上层均不成立
        }
        return num + left + right;
    }
};
```

```cpp
// 方法2
class Solution {
public:
    
    // root是否是祖节点
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root || root==p || root==q) return root;  

        auto left = lowestCommonAncestor(root->left, p, q); // left存在其中的节点
        auto right = lowestCommonAncestor(root->right, p, q);

        if(!left) return right; // left不存在，则全部在right
        if(!right) return left;

        return root; // 都不在，则root为祖
    }
};
```





## 2 路径问题

1. 回溯方式：
   * 借助全局变 —— 保存所有路径、记录符合的路径长度
   * 借助函数形参 —— 自动回溯，记录单个岔口路径
2. 路径问题，均需要两个函数，主函数调用dfs，dfs用于递归
3. * 类型：以根节点为路径起始，dfs一次递归
   * 类型：以任意节点为路径起始，(主函数、dfs)双层递归
4. * 类型：以指定节点（叶子节点，指定节点）为结束，dfs 记录路径，满足条件后直接return返回上层
   * 类型：以任意节点（满足和为tar的节点）为结束，dfs 记录路径，不需要return返回，继续往下遍历
5. 函数头模板

```cpp
// 自上而下路径
1 dfs返回值为void, 若题目不是void，则自己创建
2 返回路径题型，需要全局变量 + 形参变量，回溯保存路径
3 前序遍历
void dfs(Node* root, string path)

3 路径和问题，利用形参tar进行判断
void dfs(Node* root, int target)

4 路径和+返回路径，需要三个参数
void dfs(Node* root, string path, int target)

// maxPath 求以任意节点为起始的最大路径和
int maxPath(Node* root)
```



| 【求路径】                                                   | 解析                         |
| ------------------------------------------------------------ | ---------------------------- |
| 【模板】[二叉树到叶子节点所有路径](https://leetcode.cn/problems/binary-tree-paths/) | 固定路径，一次递归，需要返回 |
| [从叶节点开始的最小路径](https://leetcode.cn/problems/smallest-string-starting-from-leaf/description/) |                              |
|                                                              |                              |

| 【路径和】                                                   | 解析                               |
| ------------------------------------------------------------ | ---------------------------------- |
| I [判断是否存在叶子节点路径和为tar](https://leetcode.cn/problems/path-sum/submissions/557321560/) | 指定路径，单层递归，记录结果return |
| II [返回叶子节点路径和为tar的路径](https://leetcode.cn/problems/path-sum-ii/submissions/557326091/) | 指定路径，单层递归，记录结果return |
| 【模板】III [返回任意路径和为tar的路径](https://leetcode.cn/problems/path-sum-iii/description/) | 任意路径，双层递归，无需return     |

| 【非自上而下】求路径和                                       | 解析                                    |
| ------------------------------------------------------------ | --------------------------------------- |
| 【模板】[二叉树最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/) | dfs求以任意节点为起始的单边最大路径和   |
| [最长同值路径](https://leetcode.cn/problems/longest-univalue-path/) | dfs求以任意节点为起始的单边最长同值路径 |
| [两节点最长路径](https://leetcode.cn/problems/diameter-of-binary-tree/submissions/557383005/) | dfs求以任意节点为起始的单边最长路径     |



【叶子节点所有路径】

```cpp
class Solution {
public:
    vector<string> ans; // 全局
    vector<string> binaryTreePaths(TreeNode* root) {
        string path = "";  // 形参
        dfs(root, path);
        return ans;

    }
    void dfs(TreeNode* root, string path) 
    {
        if(root == nullptr) return;
        path += to_string(root->val);
        if(root->left == nullptr && root->right==nullptr) // 1 遇到叶子节点，记录路径
        {
            ans.push_back(path);
            return;  // 2 返回
        }
        else
        {
            path += "->";
        }
        if(root->left) dfs(root->left, path);
        if(root->right) dfs(root->right, path);
    }
};
```

【从叶节点开始的最小路径】

```cpp
class Solution {
public:
    vector<string> ans;
    string smallestFromLeaf(TreeNode* root) {
        if(!root) return "";

        dfs(root, "");
        sort(ans.begin(), ans.end()); // 路径排序
        return ans[0];  // 返回最小路径

    }

    void dfs(TreeNode* root, string path)
    {
        if(!root) return;

        path += 'a' + root->val;
        if(!root->left and !root->right)
        {
            reverse(path.begin(), path.end()); // 反转路径
            ans.push_back(path);
            return; // 返回
        }

        if(root->left) dfs(root->left, path);
        if(root->right) dfs(root->right, path);

    }
};
```





------------------



【I 判断是否存在路径和为tar】

```cpp
class Solution {
public:
    bool ans = false;
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(!root) return false;
        dfs(root, targetSum);
        return ans;
    }

    void dfs(TreeNode* root, int targetSum)
    {
        if(!root) return;

        targetSum-=root->val;

        if(!root->left and !root->right and !targetSum) // 1 叶子节点，且此时tar=0
        {
            ans = true; // 记录结果
            return; // 返回
        }

        if(root->left) hasPathSum(root->left, targetSum);
        if(root->right) hasPathSum(root->right, targetSum);

    }
};
```

【II 返回叶子节点为tar的路径】

```cpp
class Solution {
public:
    vector<vector<int>> ans; // 全局
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        if(!root) return ans;

        vector<int> path;  // 局部变量保存单个path
        dfs(root, targetSum, path);

        return ans;
    }
    void dfs(TreeNode* root, int targetSum, vector<int> path)
    {
        if(!root) return;

        targetSum -= root->val;  // 修改和
        path.push_back(root->val); // 加入路径
        if(!root->left and !root->right and !targetSum)  // 遇到叶子节点且tar=0
        {
            ans.push_back(path); // 记录路径， 返回
            return;
        }

        if(root->left) dfs(root->left, targetSum, path);
        if(root->right) dfs(root->right, targetSum, path);

    }
};
```

【III 返回任意路径和为tar的路径】

```cpp
class Solution {
public:
    int ans = 0;
    int pathSum(TreeNode* root, int sum) {
        if(!root) return 0;
        dfs(root, sum);
        // 递归子树，以任意节点为起始，找到和为tar的位置
        if(root->left) pathSum(root->left, sum);
        if(root->right) pathSum(root->right, sum);
        return ans;

    }
    // 以root为起始位置，找和为tar的路径
    void dfs(TreeNode* root, int sum)
    {
        if(!root) return ;

        sum-=root->val;
        if(!sum) ans++;    // 1 和为0时，记录路径   2 任意点结束，无需return

        if(root->left) dfs(root->left, sum);
        if(root->right) dfs(root->right, sum);
    }

};
```

---------

【二叉树最大路径和】

```cpp
class Solution {
public:
    // val有负数，设为int最小值
    // 全局，记录最大路径和
    int maxVal = INT_MIN;
    int maxPathSum(TreeNode* root) {
        maxpath(root);
        return maxVal;
    }
    // 后续遍历，求以root为起始的单边最大路径和
    int maxpath(TreeNode* root)
    {
        if(!root) return 0;

        int left = max(maxpath(root->left), 0); // 当左子树和为负数，则舍弃
        int right = max(maxpath(root->right), 0);

        maxVal = max(maxVal, left +right + root->val); // 全局变量更新最大路径和
        return max(left+root->val, right + root->val); // 返回root起始的最大路径和

    }

};
```

【最长同值路径】

```cpp
class Solution {
public:
    int num = 0;
    int longestUnivaluePath(TreeNode* root) {
        if(!root) return num;
        maxpath(root);
        return num;
    }
	
    // 后续遍历，求以root为起始的单边最长同值路径
    int maxpath(TreeNode* root)
    {
        if(!root) return 0;

        int left = maxpath(root->left);
        int right = maxpath(root->right);

        // 更新最长路径
        if(root->left and root->val == root->left->val) left++;
        else left = 0;
        if(root->right and root->val == root->right->val) right++;
        else right = 0;

        num = max(num, left + right);  // 更新root为顶点的最长同值变数

        return max(left, right);// 返回以root为起始的单边最长
    }
};
```

【两节点最长路径】

```cpp
class Solution {
public:
    int ans = 0;
    int diameterOfBinaryTree(TreeNode* root) {
        if(!root) return ans;
        maxPath(root);
        return ans;
    }
    // 求以root为起始点的单边最长路径
    int maxPath(TreeNode* root)
    {
        if(!root) return 0;

        int left = maxPath(root->left);
        int right = maxPath(root->right);

        if(root->left) left++;
        if(root->right) right++;

        ans = max(ans, left + right); // 更新以root为顶点的最长路径
        return max(left, right);  // 返回以root为起始的单边最长路径

    }
};
```





## 2 搜索二叉树

1. 利用特性：==中序遍历结果有序==
2. 使用==全局变量==保存遍历的前一个结果

| 题目                                                         | 解析                                      |
| ------------------------------------------------------------ | ----------------------------------------- |
| [搜索二叉树搜索节点](https://leetcode.cn/problems/search-in-a-binary-search-tree/submissions/557902144/) | 前序遍历，比较  （递归找节点）            |
| [判断是否为搜索二叉树](https://leetcode.cn/problems/validate-binary-search-tree/) | 中序遍历特性 + 全局变量记录前一个节点的值 |
| [二叉搜索树的第k小元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/description/) | 中序遍历特性 +记录前一个节点的值          |
| [最小差值](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/) | 中序遍历 + 记录前一个节点                 |
| [二叉树找众数](https://leetcode.cn/problems/find-mode-in-binary-search-tree/) | 中序遍历 + 记录前一个节点                 |
| [搜索二叉树的最近公共祖节点](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/submissions/557941373/) | 两点在异侧，则root为祖节点                |
| 根据有序表构建搜索二叉树                                     | 递归找节点的位置，插入                    |
| [插入节点](https://leetcode.cn/problems/insert-into-a-binary-search-tree/) | 递归找节点的位置，插入                    |
| 删除节点                                                     |                                           |
| 剪枝节点                                                     |                                           |

【搜索二叉树搜索节点】

```cpp
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if(!root) return nullptr;

        if(root->val == val) return root;
        if(root->val > val) return searchBST(root->left, val);
        if(root->val < val) return searchBST(root->right, val);

        return nullptr;
    }
};
```



【判断搜索二叉树】

```cpp
class Solution {
public:
    long pre = LONG_MIN;
    // 中序遍历
    bool isValidBST(TreeNode* root) {
        if (root == nullptr) return true;

        // 检查左子树
        if (!isValidBST(root->left)) return false;

        // 检查当前节点
        if (root->val <= pre) return false;
        pre = root->val;

        // 检查右子树
        if (!isValidBST(root->right)) return false;

        return true;
    }
};
```

【找到第k小的数】

```cpp
class Solution {
public:
    int count;
    int ans = 0;  // 记录前一个值
    int kthSmallest(TreeNode* root, int k) {
        count = k;
        dfs(root);
        return ans;
    }
    // 前序遍历得到有序数组，找到第k个
    void dfs(TreeNode* root)
    {
        if(root == nullptr) return;
        dfs(root->left);
        
        count--;
        if(!count) 
        {
            ans = root->val;
            return;
        }
        dfs(root->right);
    }
};
```

【最小差值】

```cpp
class Solution {
public:
    TreeNode* pre = nullptr; // 记录前一个节点
    long long ans = LLONG_MAX;
    int getMinimumDifference(TreeNode* root) {
        if(!root) return ans;

        dfs(root);
        return ans;
    }
    void dfs(TreeNode* root)
    {
        if(!root) return;

        if(root->left) dfs(root->left);

        if(!pre) pre = root;
        else
        {
            long long sub = llabs(root->val - pre->val);
            ans = min(ans, sub);
            pre = root;
        }
        if(root->right) dfs(root->right);
    }
};
```

【找众数】

```cpp
class Solution {
public:
    TreeNode* pre = nullptr;
    int count = 0;  // 记录当前最长
    int maxCount = 0; // 记录历史最长
    vector<int> ans; // 保存结果
    vector<int> findMode(TreeNode* root) {
        if(!root) return ans;

        dfs(root);
        return ans;
    }

    void dfs(TreeNode* root)
    {
        if(!root) return;

        dfs(root-> left);

        if(!pre) count = 1;
        else if(root->val == pre->val) count++;
        else count = 1;

        pre = root;
        
        if(count == maxCount) ans.push_back(root->val);
        else if(count > maxCount)
        {
            maxCount = count;
            ans.clear();
            ans.push_back(root->val);
        }

        dfs(root->right);
    }
};
```

【搜索二叉树的最近公共祖节点】

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root) return root;
		
        
        while(((long)root->val - (long)p->val) * ((long)root->val - (long)q->val)  > 0)
        {
            // 同侧,继续判断（具体去左右子树）
            root = root->val > p->val ? root->left : root->right;
        }
		// 异侧 or 重合，返回root
        return root;
    }
};
```

【二叉树插入节点】

```cpp
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        TreeNode* newNode = new TreeNode(val);

        if(!root) return newNode; // 空树

        TreeNode* pre = nullptr; // 记录父节点
        TreeNode* cur = root;
        while(cur)  // 递归找节点位置
        {
            pre = cur;
            cur = (cur->val > val) ? cur->left : cur->right;
        }
        // 判断插入
        if(pre->val > val) pre->left = newNode;
        else pre->right = newNode;

        return root;
    }
};
```



## 3 构造二叉树

思路：

1、全局变量保存数组，build()通过下标从数组中获取值，构建二叉树

2、先找到根节点，在计算左右区间的范围

3、build()传入需要构建子树的区间下标（左闭右闭）

| 题目                                                         | 解析                                       |
| ------------------------------------------------------------ | ------------------------------------------ |
| [中序+后序构建二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/) | 中序只用来求左右区间长度，后序用来划分节点 |
| [中序 + 前序构建二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/submissions/557620376/) |                                            |
| [构建最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/) | 找到最大节点以及下标                       |

1、哈希表保存中序的元素及下表

2、后序表找到根节点，从hash中得到根节点下表

3、中序表划分左右区间，得到长度，只需要左区间长度就足够

4、后序表根据左右区间长度，建立二叉树

【中序+后序构建二叉树】

```cpp
class Solution {
public:
    vector<int> post;   // 传递后序表
    unordered_map<int, int> hash;
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        if(inorder.empty()) return nullptr;

        for(int i = 0; i < inorder.size(); i++)
        {
            hash[inorder[i]] = i;  // 前序表建立哈希表(val, 索引)
        }
        post = postorder;

        return build(0, inorder.size()-1, 0, post.size() - 1);

    }
    
    // 参数：给定左右区间的下表，左闭右闭
    TreeNode* build(int in_left, int in_right, int post_left, int post_right)
    {
        if(in_right < in_left || post_right < post_left) return nullptr;

        // 1 后序表找到根节点,创建节点
        auto rootNode = new TreeNode(post[post_right]);

        // 2 中序表划分左右区间,得到长度
        int rootIndex = hash[rootNode->val];
        int leftLen = rootIndex - in_left ; 

        // 3 根据长度划分后序表，递归得左右子树
        rootNode->left = build(in_left, rootIndex - 1, post_left, post_left + leftLen - 1);
        rootNode->right = build(rootIndex + 1, in_right, post_left + leftLen , post_right - 1);
        
        return rootNode;

    }
};
```

【前序+ 中序】

```cpp
class Solution {
public:
    unordered_map<int, int> hash;
    vector<int> preVec;

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if(preorder.empty()) return nullptr;

        for(int i = 0; i < inorder.size(); ++i)
        {
            hash[inorder[i]] = i;
        }
        preVec = preorder;

        return build(0, inorder.size()-1, 0, preorder.size()-1);
    }

    TreeNode* build(int in_left, int in_right, int pre_left, int pre_right)
    {
        if(in_right < in_left || pre_right < pre_left ) return nullptr;

        // 1 获取根节点
        auto rootNode = new TreeNode(preVec[pre_left]);
        int rootIndex = hash[rootNode->val];

        // 2 划分长度
        int leftLen = rootIndex - in_left; 

        // 3 递归得左右子树
        rootNode->left = build(in_left, rootIndex - 1, pre_left + 1, pre_left  + leftLen);
        rootNode->right = build(rootIndex + 1, in_right, pre_left + 1 + leftLen, pre_right);

        return rootNode;
    }
```

【构建最大二叉树】

```cpp
class Solution {
public:
    vector<int> vec;
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        if(nums.empty()) return nullptr;
        vec = nums;
        return build(0, nums.size() - 1);
    }

    TreeNode* build(int left, int right)
    {
        if(right < left) return nullptr;

        // 获取最大节点-根节点
        // 注意查找的范围需要变化
        auto maxit = std::max_element(vec.begin() + left, vec.begin()+right+1);
        auto rootNode = new TreeNode(*maxit);

        // 左右区间长度
        int index;
        if(maxit != vec.end())
        {
            index = std::distance(vec.begin(), maxit);
        }

        rootNode->left = build(left, index - 1);
        rootNode->right = build(index + 1, right);

        return rootNode;
    }
};
```





# 动态规划

* 【动态五步曲】

* 做题步骤：创建dp表，填满  数据，表中的某项就是最终的结果

  1. 状态表示

     dp表中的某一个值的具体含义

     怎么获取？ 

      1、题目要求 

      **2、经验+题目要求**  【以i位置为结束位置 / 选择到i的时候， 根据题目需要的条件xxxx】

      3、分析问题中，发现重复子问题，抽象子问题出来

  2. 状态转移方程 （最难、核心）

     dp[i]等于什么? 怎么填充dp表

  3. 初始化

     保证填表不越界，根据状态转移方程，给出越界的情况，即让 i- n >= 0
  
  4. 填表顺序
  
     从左往右填表、从右往左填表
  
  5. 返回值，单独返回边界情况
  
     返回值，即将 i 变为 数据大小n, 例如：dp[i], return dp[n]

* 【做题步骤】
  1. 创建dp表，确定状态转移方程
  2. 初始化，给出前提状态
  3. 按照填表顺序，填表
  4. 返回值，单独返回边界情况

* 空间优化--背包问题---利用滚动数组

<img src="https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240801232736787.png" alt="image-20240801232736787" style="zoom:67%;" />



| 题目            | 状态表示                 | 状态转移方程                        |
| --------------- | ------------------------ | ----------------------------------- |
| 第N个泰波那契数 | dp[i] ： 第i个泰波那契数 | dp[i] = dp[i-3] + dp[i-2] + dp[i-3] |
|                 |                          |                                     |
|                 |                          |                                     |
|                 |                          |                                     |

【第N个泰波那契数】

```cpp
class Solution {
public:
    int tribonacci(int n) {
        // 0 处理越界
        if(n==0) return 0;
        if(n==1 || n==2) return 1;
        // 1 创建dp表
        vector<int> dp(n + 1);

        // 2 初始化，填充已有数据
        dp[0] = 0;
        dp[1]= dp[2] =1;

        // 3 循环填表
        for(int i = 3; i <= n; ++i){
            dp[i] = dp[i-1] + dp[i-2] + dp[i-3];
        }

        // 4 返回值
        return dp[n];
    }
};
```

```cpp
// 滚动数组-空间优化
class Solution {
public:
    int tribonacci(int n) {
        // 0 处理越界
        if(n==0) return 0;
        if(n==1 || n==2) return 1;
        // 1 创建dp表（滚动数组） 2 初始化
        int a = 0, d = 0;
        int b = 1, c = 1;

        // 3 循环填表
        for(int i = 3; i <= n; ++i){
            d = a + b + c;
            // 滚动
            a = b;b = c; c = d;
        }

        // 4 返回值
        return d;
    }
}
```

## 打家劫舍

1. 多状态：到dp[i]的时候，会有多种状态
2. 根据多个状态，将dp[i]分成f[i]、g[i]d等对应的dp表
3. 不同的dp表相互依赖
4. 返回的结果，可能跟多个dp表有关

* 打家劫舍问题：
* 在一维数组中，选中一个元素，即不能选取下一个元素，求最终选取的元素和的最大值
* 要求1：必须在下表连续的数组中    
* 要求2：每个位置上必须有值

| 题目                                                         | 状态表示                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [按摩师](https://leetcode.cn/problems/the-masseuse-lcci/description/) | dp[i] ： 选择到i位置的时候，预约的最大值                     |
| [打家劫舍I](https://leetcode.cn/problems/house-robber-ii/)   | dp[i] ： 选择到i位置的时候，盗窃的最大值， 一维数组，等同于按摩师 |
| [打家劫舍II](https://leetcode.cn/problems/house-robber-ii/)  | 环形数组，分情况讨论，转化为打家劫舍I                        |
| [删除并获得点数](https://leetcode.cn/problems/delete-and-earn/description/) | 转换为打家劫舍，构建连续数组arr                              |



【按摩师】

![image-20240801235005256](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240801235005256.png)

```cpp
// 模板
class Solution {
public:
    int massage(vector<int>& nums) {
        
        // 0 返回边界情况
        if(nums.empty()) return 0;

        // 1 两个dp表
        int n = nums.size();
        vector<int> f(n, 0);
        auto g = f;

        // 2 初始化
        f[0] = nums[0]; g[0] = 0;

        // 3 按从左到右同时填表
        for(int i = 1; i < n; ++i)
        {
            f[i] = g[i - 1] + nums[i];
            g[i] = max(f[i - 1], g[i - 1]);
        }
        return max(f[n - 1], g[n - 1]);
    }
};
```

【打家劫舍II】

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        // 1. 选中第一个，则第二个和第n个不选，从第2个到第n-1个打家劫舍1
        // 2. 不选第一个，则从第二个到第n个打家劫舍1
        return max(nums[0] + rob1(nums, 2, n-2), rob1(nums, 1, n-1));

    }

    // 在某段区间内打家劫舍，
    int rob1(vector<int>& nums, int left, int right)
    {
        if(right < left) return 0;
        // 创建dp表
        vector<int>f(nums.size(), 0);
        auto g = f;

        // 初始化
        f[left] = nums[left];
        g[left] = 0;

        // 填表
        for(int i = left + 1; i <= right; ++i)
        {
            // 选择到第i个的时候，之前的最大值
            f[i] = g[ i - 1] + nums[i];
            g[i] = max(f[i-1], g[i-1]);
        }
        // 返回
        return max(f[right], g[right]);
    }
};
```

【删除并获取点数】

```cpp
class Solution {
public:
    int deleteAndEarn(vector<int>& nums) {
        // 打家劫舍要求连续数组中
        const int N = 10001;
        // 下表index的元素表示nums总共有的index的和
        vector<int> arr(N, 0);
        
        for(auto val : nums)
        {
            arr[val] += val;
        }
        // 打家劫舍
        vector<int> f(N, 0);
        auto g = f;

        f[0] = arr[0];
        g[0] = 0;

        for(int i = 1; i < arr.size(); ++i)
        {
            f[i] = g[i-1] + arr[i];
            g[i] = max(f[i-1], g[i-1]);
        }
        return max(f[arr.size() - 1], g[arr.size() - 1]);
    }
};
```



## 股票买卖

1. 状态机：一天的三种状态‘ ： 持仓、 空闲、 冷冻
2. 分析每一种状态怎么转移（今天的状态怎么由前一天的状态转换）

| 问题          | 1    |
| ------------- | ---- |
| 手续费        |      |
| 冷冻期        |      |
| 只允许交易k次 |      |

【手续费】

<img src="https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240325000650843.png" alt="image-20240325000650843" style="zoom:50%;" />

```cpp
// 3-25
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        vector<vector<int>>dp(n, vector<int>(2));

        dp[0][0] = -prices[0] - fee;
        for(int i = 1; i < n; ++i){
            // 持仓
            dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[i]-fee);
            // 空闲
            dp[i][1] = max(dp[i-1][1], dp[i-1][0]+prices[i]);
        }
        return max(dp[n-1][0], dp[n-1][1]);

    }
};
```



【冷冻期】

<img src="https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240324235923923.png" alt="image-20240324235923923" style="zoom:50%;" />

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // dp表，三种状态
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(3));

        dp[0][0] = -prices[0];
        for(int i = 1; i < n; ++i){
            // 持仓
            dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[i]);
            // 空闲
            dp[i][1] = max(dp[i-1][2], dp[i-1][1]);
            // 冷冻
            dp[i][2] = dp[i-1][0] + prices[i];
            
        }
        return max(dp[n-1][1], dp[n-1][2]);


    }
};
```



【交易k次】

状态表：三维数组 [天数] [状态] [交易次数]

将1个三维数组，转换为两个2维数组

```cpp
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        int n = prices.size();
        const int MIN = -0x3f3f3f3f;
        // 最多交易k次， 加上0，有k+1次状态
        vector<vector<int>> f(n, vector<int>(k+1, MIN)); // 持仓
        auto g = f; // 空闲

        // 初始化
        f[0][0] = -prices[0];
        g[0][0] = 0;

        // 状态方程
        for(int i = 1; i < n; ++i){
            // 根据次数再次填充
            for(int j = 0; j < k+1; j++){
                f[i][j] = max(f[i-1][j], g[i-1][j] - prices[i]);
                // 判断j为0，即第i天都没有交易过，所以不存在持仓到空闲的转换
                if(j == 0) g[i][j] = g[i-1][j];
                else g[i][j] = max(g[i-1][j], f[i-1][j-1] + prices[i]);
            }
        }

        // 返回值
        int ret = MIN;
        for(auto p : g[n-1]){
            ret = max(ret, p);
        }
        return ret;

    }
};
```





## 回文串

| 题目                                                         | 解决                                 |
| ------------------------------------------------------------ | ------------------------------------ |
| [回文子串的个数](https://leetcode.cn/problems/palindromic-substrings/submissions/516429663/) | 统计dp表中true的个数                 |
| [最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/description/) | 变量保存回文串的长度                 |
| [分割三块子串是否为回文串](https://leetcode.cn/problems/palindrome-partitioning-iv/submissions/516675056/) | 统计所有回文串，遍历所有分三块的子串 |
|                                                              |                                      |
|                                                              |                                      |
|                                                              |                                      |
|                                                              |                                      |



1. 从前往后、从后往前读的字符都一样， abba
2. 使用二维dp表，存储 [i,j] 子串是否为回文串， 且使用二维表的上三角区域存储
3. 状态转移方程：判断前后字符一样的情况下，判断内部子串是否为回文串

```cpp
class Solution {
public:
    int countSubstrings(string s) {
        // 存储是否为回文子串
        int n = s.size();
        vector<vector<bool>> dp(n, vector<bool>(n, false));

        // 状态转移方程+填表顺序  --. 从下往上
        int num = 0;
        for(int i = n -1; i >=0 ; --i){
            for(int j = i; j < n; ++j){
                // 判断前后元素相等，继而判断中间元素回文
                if(s[i] == s[j]) dp[i][j] = ((i == j )|| (i+1 == j)) ? true : dp[i+1][j-1];
                if(dp[i][j] == true) num++;
            }        
        }
        return num;

    }
};
```

## 子数组

| 题目                                                         | 求解                            |
| ------------------------------------------------------------ | ------------------------------- |
| [最大子数组和](https://leetcode.cn/problems/maximum-subarray/) | 以i为结尾的所有子数组中的最大和 |
| [环形数组下的最大子数组和](https://leetcode.cn/problems/maximum-sum-circular-subarray/) | 转换为求最小子数组和            |
| [最大子数组乘积](https://leetcode.cn/problems/maximum-product-subarray/submissions/516759976/) | 注意i位置的正负的最大值计算方法 |
| [乘积为正数的最长子数组](https://leetcode.cn/problems/maximum-length-of-subarray-with-positive-product/description/) | 区分num[i]为正负0的三种情况     |

## 背包

[模板总结](https://leetcode.cn/problems/last-stone-weight-ii/solutions/805162/yi-pian-wen-zhang-chi-tou-bei-bao-wen-ti-5lfv/)

​	

# 总结

## 1 递归、循环、深搜

1. 深度优先遍历 ： 前序遍历、 中序遍历、后序遍历

2. 递归的展开图本质是对数的深度优先遍历

3. 递归和循环都是解决同一类问题，因此，递归和循环可以转换

   当递归树复杂，多叉时候，递归方便，当递归树单支，循环方便

<img src="https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures/img/202407091354365.png" alt="image-20240709135442968" style="zoom:50%;" />

# 章节分类

## 1 数组

* 针对数组本身--增删改查

| 题目                                                         | 解法               |
| ------------------------------------------------------------ | ------------------ |
| 【增】合并有序数组                                           | 从后往前模拟       |
| 【删】[删除数组重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/) | 朴素双指针         |
| 改                                                           |                    |
| 【查】查找数组元素/区间                                      | 朴素二分、升级二分 |

* 数组其他题型

| 题目                | 解法     |
| ------------------- | -------- |
| 快乐数              | 快慢指针 |
| 两数之和【求值】    | 哈希表   |
| 两数之和【求下表】  | 对撞指针 |
| 三数之和【求下表】  | 对撞指针 |
| 无重复值最长子串    | 滑动窗口 |
| 水果成篮            | 滑动窗口 |
| 有重复值的第K大元素 | 快速选择 |
| 有重复值的前K大元素 | 快速选择 |
| 合并有序数组        | 模拟     |
| 前缀和              | 前缀和   |
| 和为K的子数组个数   | 前缀和   |



## 2 链表

1. 链表删除操作，统一删除头节点的操作，加入虚节点

| 题目                                                         | 解法                     |
| ------------------------------------------------------------ | ------------------------ |
| 【增】[合并有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/description/) | 递归                     |
| 【删】一遍遍历删除倒数第N个节点                              | 朴素双指针 + 虚节点      |
| 【删】删除链表重复元素，留一位                               | tail+head双指针 + 虚节点 |
| 【删】删除链表重复元素，全部删除                             | tail+head双指针 + 虚节点 |
| 【改】链表反转                                               | 递归                     |
| 【改】两两反转                                               | 递归                     |
| 【改】k个一组反转                                            | 递归                     |
| 【查】环形链表                                               | 快慢指针                 |
| 【查】链表相交公共节点                                       | 双指针走相同路径         |
| 【查】逆序打印链表                                           | 栈                       |

| 题                                                           | 解法   |
| ------------------------------------------------------------ | ------ |
| [复杂链表的深拷贝](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/solutions/1709154/by-ac_oier-6atv/) | 哈希表 |



【合并有序链表】

```cpp
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        // 出口
        if(list1 == nullptr) return list2;
        if(list2 ==nullptr) return list1;

        if(list1->val <= list2->val)
        {
            list1->next = mergeTwoLists(list1->next, list2);
            return list1;
        }
        else
        {
            list2->next = mergeTwoLists(list1, list2->next);
            return list2;
        }
    }
```

【删除链表倒数第N个元素】

```cpp

class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* newNode = new ListNode;
        newNode->next = head;
        ListNode* left = newNode, *right = newNode;
        // 前进n步
        while(n--)
        {
            right = right->next;
        }
        while(right->next)
        {
            right = right->next;
            left = left->next;
        }
        // 此时left指向倒数第n个节点的前一个节点
        left->next = left->next->next;
        return newNode->next;
    }
};
```

【删除重复节点，保留1位】

1 设置虚节点

2 尾指针指向有效链表的结尾

3 head用于遍历链表，当head节点和尾节点的值不同时，将head加入到tail后

```cpp
ListNode* deleteDuplicates(ListNode* head) {
    if(!head) return head;
    ListNode* dummp = new ListNode(-101);
    ListNode* tail = dummp;

    while(head)
    {
        // 当head节点和尾节点的值不同时，将head加入到tail后
        if(head->val != tail->val)
        {
            tail->next = head;
            tail = head;
        }

        head = head -> next;
    }
    tail->next = nullptr;
    return dummp->next;
}
```

【删除所有重复元素】

``` cpp
ListNode* deleteDuplicates(ListNode* head) {
    if(!head) return head;
    ListNode* dummp = new ListNode(-109);
    ListNode* tail = dummp;

    while(head)
    {
        // 当head是最后一个节点，或者 head和下一个节点的val不是重复值
        if(head->next == nullptr or head->val != head->next->val)
        {
            tail->next = head;
            tail = head;
        }
        // 重复元素，head往后移动
        while(head->next and head->val == head->next->val)
        {
            head = head->next;
        }
        // 
        head = head->next;
    }
    tail->next = nullptr;
    return dummp->next;
}
```

【链表相交公共节点】

<img src="https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures/img/202408201120593.png" alt="image-20240820112021002" style="zoom:50%;" />

* 每个链表走完之后，走对方的链表，则每条链条走过的路都是ad + dc + bd
* 若无公共节点，则每条链表走的都是ac + bc，最终走到null
* 因此，当p = q 相等时，一定是d节点或null节点

```cpp
ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
    ListNode* p =headA, *q = headB;
    while(p != q)
    {
        p = (p==nullptr) ? headB : p->next;
        q = (q==nullptr) ? headA: q->next;
    }
    return p;
}
```

【复杂链表的深拷贝】

* 使用哈希表记录旧节点与新节点
* 通过旧节点的关系，设置新节点的关系

```cpp
Node* copyRandomList(Node* head) {
    unordered_map<Node*, Node*> hash;

    // 创建新节点映射
    Node* cur = head;
    while(cur != nullptr)
    {
        hash[cur] = new Node(cur->val);
        cur = cur->next;
    }
    // 设置对应关系
    cur = head;
    while(cur != nullptr)
    {
        hash[cur]->next = hash[cur->next];
        hash[cur]->random = hash[cur->random];
        cur = cur->next;
    }
    return hash[head];
}
```









## 3 字符串

[模板总结](https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof/solutions/804817/yi-ge-mo-ban-shua-bian-suo-you-zi-fu-chu-x6vh/)

1. 创建`arr[128]`充当哈希表，记录某个字符是否存在

| 题目                 | 解法     |
| -------------------- | -------- |
| 无重复字符的最长子串 | 滑动窗口 |





