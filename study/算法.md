[学习文档1](E:\typora索引文件\c++\算法\优选算法精品课_课件.pdf)

[学习文档2](E:\typora索引文件\c++\算法\优选算法二.pdf)

[动态规划](F:\学习视频\比特就业课c++\资料\精品课课件\动态规划\动态规划.pdf)

"F:\学习视频\比特就业课c++\资料\精品课课件\动态规划"

# 腾讯

1.自我介绍

2.lru（在线ide太恶心了，不会用，导致写了二十多分钟，麻了，还得自己打样例）

3.lru还能怎么优化（面试官说得考虑线程安全。。。）

4.osi七层和tcp/ip四层

5.tcp三握四挥

6.tcp和udp的区别

7.网页输入url

8.c和c++的差别

9.引用与指针

10.new/malloc和delete/free的区别

11.内存分配的几种方式和如何进行管理

12.三大智能指针内部实现和做什么的

13.虚函数和纯虚函数的区别和内部实现

14.线性表的实现方法

15.数组和链表的区别

16.队列和栈的区别

17.二叉搜索树

18.二叉平衡树

19.二叉树的深度优先遍历

20.通过什么方式实现（递归和不递归的两种方式）

21.有个数组，找出数组中出现次数最多的（要通解，一眼哈希表）

22.死锁

23.怎么实现死锁查找器

24.自旋锁和互斥锁的区别

25.什么是临界区（不会）

26.什么是优先级反转（不会）



c++客户端，没录屏八股只记得一部分
3.12一面：
八股：
1.堆和栈
2.静态库和动态库 
3.如何保证线程安全
4.使用锁的缺点
5.创建内存有什么方式，其中的区别
6.虚函数实现原理
7.野指针和悬空指针，怎么避免
8.知道几种IO模型
9.tcp传输的内容如何加密
10.tcp滑动窗口，有什么用
算法：
1.两个升序链表，合并成一个升序/降序链表
2.一个无序链表，变成升序的 （以及如何调用第一题的方法实现）

3.13二面
八股：
1.git reset和revert
2.merge和rebase，分别适用什么情况
3.share_ptr，有什么用，怎么实现
4.如何用udp实现tcp
5.如何用tcp实现http
6.知道http2？和http1的区别
7.三种IO多路复用的区别
8.tcp黏包，怎么解决
场景题：
IO多路复用，间隔两秒按序对三个ip发请求，保持所有连接直到其中一个accept。
算法：
1.链表每隔k个元素进行翻转，如果最后不足k个保持不变
2.返回无序数组第k大的数

# 数据结构常用操作

## 1 排序

```cpp
std::sort(vector.begin(), vector.end()); // vector需要全局的sort
list<int> lis;
lis.sort(); // 含有成员变量sort
```

## 2 算法循环

| 算法       | 循环                                       | 注意                     |
| ---------- | ------------------------------------------ | ------------------------ |
| 分块双指针 | `for(int cur = 0; cur < nums.size(); i++)` |                          |
| 快慢指针   | `while(slow < fast)`                       |                          |
| 对撞指针   | `while(left < right)`                      |                          |
| 滑动窗口   | `while(条件失效)`                          |                          |
| 二分查找   | `while(left <= right)`                     | 闭区间有效， <=          |
| 快排、快查 | `while(i < right)`                         | 当前处理位置 < right位置 |
|            | ``                                         |                          |

![image-20240731103757461](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures/img/202407311037688.png)

-----------



# 双指针

| 分块双指针                                                   | 快慢双指针                          | 对撞双指针（要求升序）                                       |
| ------------------------------------------------------------ | ----------------------------------- | ------------------------------------------------------------ |
| 一个指针遍历（for循环挨个处理数组），一个指针标识处理好的数据最后一位 | 一个走一步，一个走两步（while循环） | 首尾指针向中间走，（while循环）                              |
| 解决：数组分块问题                                           | 解决：判断是否有环                  | 解决：两数之和和第三个数比较                                 |
| 数组分两块（移动0）：非0   0                                 | 快乐数                              | [构成三角形最大个数](https://leetcode.cn/problems/valid-triangle-number/) |
| 复写0                                                        |                                     | [水桶装最多水](https://leetcode.cn/problems/container-with-most-water/) |
| 数组分三块（颜色划分、快排）：0 1 2 （三指针）               |                                     | 两数之和、三数之和、去重、返回所有值                         |

【移动0 ， 双指针， 分两块】[leetcode](https://leetcode.cn/problems/move-zeroes/)

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int des = -1; // 起始位置-1
        // 双指针
        for(int cur = 0; cur < nums.size(); ++cur){
            if(nums[cur] ){
                swap(nums[++des], nums[cur]);
            }

        }
    }
};
```



【颜色分块，三指针，分三块】[leetcode](https://leetcode.cn/problems/sort-colors/)

```cpp
// 指针在前，r指针在后，中间为待处理区class Solution {
public:
    void sortColors(vector<int>& nums) {
        int len = nums.size();
        int left = -1;
        int right = len;
        int i = 0;
        while(i < right){
            if(nums[i] == 0) swap(nums[++left], nums[i++]);
            else if(nums[i] == 1) i++;
            else swap(nums[--right], nums[i]);
        }
        
    }
};

```



【有序数组】双指针、二分查找

【两数之和--返回下标】哈希表   【两数之和--返回元素】排序对撞指针

```cpp
// 下标
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> hash;

        for(int i = 0; i < nums.size();++i)
        {
            int key = nums[i];
            hash[key] = i;
        }
        for(int i = 0; i < nums.size(); ++i)
        {
            int key = target - nums[i];
            if(hash.find(key) != hash.end())
            {
                // 找到
                if(hash[key] != i)
                {
                    // 去重
                    return {i, hash[key]};
                }
            }
        }
        return {-1, -1};
    }
};

// 元素（对撞）
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while(left < right)
        {
            int sum = nums[left] + nums[right];
            if(sum > target) right--;
            else if(sum < target) left++;
            else return {left, right};
        }
        return {-1, -1};
    }
};
```



# 滑动窗口

| 滑动窗口（同向双指针）                                       | 2                              |
| ------------------------------------------------------------ | ------------------------------ |
| 解决： 满足条件的==最短/最长==连续子串                       |                                |
| [子串值和>=tar的最短子串](https://leetcode.cn/problems/minimum-size-subarray-sum/description/) |                                |
| [子串值和>=tar的最长子串](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/) |                                |
| [无重复值最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/) | 数组模拟哈希表                 |
| [最多包含两种数的最长子串](https://leetcode.cn/problems/fruit-into-baskets/)【水果成篮】 | 哈希表                         |
| [连续相同值的最长子串](https://leetcode.cn/problems/max-consecutive-ones-iii/description/) | 反转0                          |
| [找到字符串的所有异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/)， [找到字符串的以（字符串为组合）的异位词](https://leetcode.cn/problems/minimum-window-substring/) | 哈希 + 有效词计数              |
| // 固定滑动窗口                                              |                                |
| [删除链表的倒数第n个节点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/) | 右指针先走，构建固定的滑动串口 |

* 右指针在for循环内默认一直划入
* while判断是否滑出

* 左指针移动，画出窗口

* 滑动窗口常常结合哈希表进行判断，哈希表有unordered_map、数组等

```cpp
// 右指针一直滑出
for(int right = 0, left = 0; right < n; ++right){
    // 1 执行滑入操作，影响判断条件
    ....
    while(// 2 判断条件失效){
        // 3 左指针执行滑出操作,直到条件重新满足
        .....
        left ++;
	}
	// 4 输出结果，根据情况。放在1 3 4
    return ret;
}
```



```cpp
int minSubArrayLen(int target, vector<int>& nums) {
        int len = nums.size(), sum = 0, ret = INT_MAX;
        for(int i = 0, j = 0; i < len; ++i){
            sum+=nums[i];
            while(sum >= target){
                ret = min((i - j + 1), ret);
                // 滑出
                sum-=nums[j];
                j++;

            }

        }
        return ret==INT_MAX ? 0 : ret;

    }
```

# 二分查找

* 数组必须有序（非递增、非递减）
* 无论朴素二分or升级二分，判断大小时，固定tar，判断mid落在哪一个区间。

| 类型                                             | 方法     |
| ------------------------------------------------ | -------- |
| 找固定的一个位置或者==一个数==                   | 朴素二分 |
| 找==一段区间==的左右端点，区间内数一致或者不一致 | 升级二分 |

```cpp
// 朴素二分
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1; 
        while (left <= right) { // 1 当left==right，区间[left, right]依然有效，所以用 <=
            int middle = left + ((right - left) / 2);// 2 防止溢出 等同于(left + right)/2
            if (nums[middle] > target) {
                right = middle - 1; 
            } else if (nums[middle] < target) {
                left = middle + 1; 
            } else { 
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        
        return -1;// 未找到目标值
        return left; // 插入位置 == right + 1,  此时left > right ，right为小于target的最后一个元素
    }
};
```

------------



升级二分查找步骤：

1. 根据条件选择一个固定点，将数组分为两个区间：结果区间 和 跳出区间
2. mid落在结果区间，则left（right）移动不能超过mid，落在移动区间，则left（right）跳出mid
3. 找右结果区间的左端点，将区间化为两份，若mid落在左区间，则left想跳出来，所以left = mid + 1, 落在右区间，right不能超过mid ，所以right = mid
4. 找做结果区间的右端点，将区间化为两份，若mid落在左区间，则left不能超过mid，所以left = mid，落在右区间，则right要跳出来，right = mid - 1

最终结果为 mid = left = right，判断该位置是否等于target

```cpp
// 升级二分
```



![image-20240312214030888](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240312214030888.png)

![image-20240312213603909](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240312213603909.png)

| 类型                                                         | 题目                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image-20240312225421888](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240312225421888.png) | [题](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/submissions/511092837/) |
| ![image-20240312225536890](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240312225536890.png) | [题](https://leetcode.cn/problems/peak-index-in-a-mountain-array/description/) |
| ![image-20240312230757122](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240312230757122.png) | [题](https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/)   |



```cpp
// 升级二分
// 找一样的数的起始结束
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        // 边界
        if(nums.size() == 0 ) return {-1, -1};
        int left = 0，right  = nums.size() -1;

        // 左
        while(left < right){               // 1 不同点
            int mid = left + ((right - left)/2);
            if(nums[mid] < target) left = mid + 1;
            else right = mid; // 2 其余两种情况合并
        }
        
        // 循环结束时： left = right
        int begin = -1;
        if(nums[left] == target)  begin = left; // 找到tar左端点
        else return{-1,-1}; // 不存在
        // 右
        // 查找区间[left, 右区间终点]
        right = nums.size() - 1;
        while(left < right){
            int mid = left + ((right - left + 1) / 2);  // mid赋值改变
            if(nums[mid] > target) right = mid - 1;
            else left = mid;
        }
        // 左端点存在，则一定存在右端点
        return {begin, right};
    }
};
```



# 前缀和

| 类型                                 | 算法                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| 解决：求已知的连续一段数组的和或积   |                                                              |
| 一维前缀和                           | 位置i表示位置i之前的所有和、表示加上i以及之前的所有和        |
| 二维前缀和                           |                                                              |
| 解决：求和为k的连数数组的个数        | [leetcode](https://leetcode.cn/problems/product-of-array-except-self/) |
| 解决：求某元素的左右两段区域的和或积 | 1. 不计算当前i在前缀内   2  需要设置f[0] 和 g[n-1] 位0或1    |
| 一维前缀和 +  一维后缀和             | 后缀数组从后往前填充值，g[i] = g[i+1] +vec[i]; [题目](https://leetcode.cn/problems/find-pivot-index/submissions/511534400/) |
| 一维前缀积 +  一维后缀积             | [leetcode](https://leetcode.cn/problems/product-of-array-except-self/) |

步骤：1 定义相同大小的前缀和数组dp

​			2 每一个位置的值等于该值到下标起始点的和

​			3 和 = vec[该位置] + dp[前面位置]

【一维前缀和】

* 求数组内某一段区间的和
* 时间复杂度 O(n)

<img src="C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240313202900943.png" alt="image-20240313202900943" style="zoom: 67%;" />







<img src="C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240313202934221.png" alt="image-20240313202934221" style="zoom:67%;" />

```cpp
#include <iostream>
using namespace std;
#include <vector>

int main(){
    int n, q;
    cin >> n >> q;

    vector<int> vec(n + 1);
    for(int i = 1; i <= n ; ++i){
        cin >> vec[i];
    }

    // 1 求前缀数组
    vector<long long > dp(n + 1);
    for(int i = 1; i <=n; ++i){
        dp[i] = dp[i-1] + vec[i];
    }

    // 2 求范围和
    int l,r;
    while(q--){
        cin >> l >> r;
        cout << dp[r] - dp[l-1] << endl;

    }
    return 0;
}
```

【二维前缀和】

* 求一块矩阵的和

![image-20240313211626949](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240313211626949.png)

```cpp
#include <iostream>
using namespace std;
#include <vector>

int main() {
    int n, m, q;
    cin >> n >> m >>q;
    vector<vector<int>> vec(n+1, vector<int>(m + 1));
    for(int i = 1; i <= n; ++i){
        for (int j = 1; j <=m; ++j){
            cin >> vec[i][j];
        }
    }

    // 1 创建前缀和矩阵
    vector<vector<long long>> dp(n+1, vector<long long>(m + 1));
    for(int i = 1; i <= n; ++i){
        for (int j = 1; j <=m; ++j){
            dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + vec[i][j];
        }
    }

    // 2 使用
    int x1, y1, x2, y2;
    while(q--){
        cin >> x1 >> y1 >> x2 >> y2;
        cout << dp[x2][y2] - dp[x1-1][y2] - dp[x2][y1-1] + dp[x1-1][y1-1] << endl;
    }
    return 0;

}

```

【前缀积 + 后缀积】

![image-20240313223746626](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240313223746626.png)



```cpp
// 2024-3-13
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int len = nums.size();
        vector<int> f(len), g(len);
        f[0] = 1;
        g[len-1] = 1;
        for(int i = 1; i < len; ++i ){
            f[i] = f[i - 1] * nums[i - 1];
        }
        for(int i = len -2; i>=0; --i){
            g[i] = g[i+1] * nums[i+1];

        }
        vector<int> res(len);
        for(int i = 0; i< len; ++i){
            res[i] = f[i] * g[i];
        }
        return res;
    }
};
```



【求和为k的连续数组】

![image-20240313232516345](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240313232516345.png)



```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int,int> hash; // <i到0的前缀和， 个数>
        int sum = 0, ret = 0;
        hash[0] = 1;
        for(auto e: nums){
            sum+=e; // 前缀和
            if(hash.count(sum - k)) ret+=hash[sum-k]; //统计个数
            hash[sum]++;
        }
        return ret;

    }
};
```

# 位运算

![image-20240314224516512](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240314224516512.png)

| 需求                   | 操作                                          |
| ---------------------- | --------------------------------------------- |
| &                      | 有0为0                                        |
| \|                     | 有1为1                                        |
| ^异或                  | 同为0，异为1，无进位相加   （1+0 = 0  1+1=0） |
| 判断数n的x位为1？0     | `(n>>x) & 1  ` 与上1                          |
| 将数n的x位变为1        | `n |=(1<<x) `  或上1                          |
| 将数n的x位变为0        | n &=(0 << x)  与上0                           |
| 提取数n二进制最右边的1 | `n & (-n)`                                    |
| 删除数n二进制最右边的1 | `n & (n -1)`                                  |
| ^的运算规律（消消乐）  | n ^ n =0 ; n^0=0   ;a^ b ^ c = a^(b ^ c)      |
|                        |                                               |

【判断字符串字符是否出现次数唯一】

```cpp
// 2024-3-14
class Solution {
public:
    bool isUnique(string astr) {
        if(astr.size() > 26) return false;
        int bit = 0;
        for(auto e : astr){
            // 存放在第x位置
            int x = e - 'a';
            // 判断x位置是0还是1
            if((bit >> x) & 1 == 1) return false;
            else {
                // 加入位图
                // 修改x位置为1
                bit |= (1<<x);
            }
            
        }
        return true;

    }
};
```

【找丢失的数字】

```cpp
// 3-14
// 通过异或来消消乐
// 即nums的数和【0，n】的所有数字异或，消消乐，剩余消失的数字
// 根据分配率，可以先异或nums，再异或[0,n]
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int bit = 0;
        for(auto e: nums) bit^=e;
        for(int i = 0; i <=nums.size(); ++i) bit^=i;
        return bit;

    }
};
```

【两数相加】

```cpp
class Solution {
public:
    int getSum(int a, int b) {
        while(b != 0){
            // 无进位相加
            int sum = a ^ b;
            // 求进位
            int car = (a & b) << 1;
            a = sum;
            b = car;
        }
        return a;

    }
};
```

<img src="C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240314234337400.png" alt="image-20240314234337400" style="zoom:67%;" />

# 快排

> 三段快排，适合于含有重复值的vec排序
>
> 排序后[l, left], [left+1, right-1], [right, r]，中间段为重复值

* 利用颜色分块的思想
* 根据随机值选取key
* 根据key分为三段区间
* 递归调用排序

```cpp
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        //  1 设随机数种子
        srand(time(NULL));
        qsort(nums,0, nums.size()-1);
        return nums;

    } 
    void qsort(vector<int>&nums, int l, int r){         // 1 传入引用
        if(l>=r) return;                                  // 2 边界判断
        int key = getKey(nums, l, r);
        // 分三块，比key小的放左边，大的放右边
        int i = l, left = l - 1, right = r+1;           // 3 快排主体（根）
        while(i<right){
            if(nums[i] < key) swap(nums[++left], nums[i++]); // （先移动指针，再交换）
            else if(nums[i] == key) ++i;
            else swap(nums[--right], nums[i]); // 4 i不自增

        }
        // [l left][left+1, right-1][right,r]
        qsort(nums,l,left);              // 5 递归（左右）
        qsort(nums,right,r);

    }
    int getKey(vector<int>&nums, int l, int r){
        // 通过随机数设置
        int ra = rand();
        return nums[ra % (r - l + 1) + l];  // 随机数 % nums长度 + left
    }
};

```

## Topk问题

| 问题          | 算法(堆排序、快速选择算法) |
| ------------- | -------------------------- |
| 返回第K大元素 |                            |
| 返回第K小元素 |                            |
| 返回前K大元素 |                            |
| 返回前K小元素 |                            |

* 快速选择算法

![image-20240322121650568](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240322121650568.png)

```cpp
// topk
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        srand(time(NULL));
        return qchoose(nums, 0, nums.size()-1, k);
    }
    
    // 快速选择
    int qchoose(vector<int>& nums, int l, int r, int k){
        if(r ==l ) return nums[l];
        int key = getKey(nums, l, r);
        // 1 快排（先移动指针，再交换）
        int i = l, left = l - 1, right = r + 1;
        while( i < right){
            if(nums[i] < key) swap(nums[++left], nums[i++]);
            else if(nums[i] == key) i++;
            else swap(nums[--right], nums[i]);
        }

		// 一、返回第k小
        // 2 选择性递归[l, left][left + 1, right -1][right, r]
        int leftLen = left - l + 1
        int midLen = right - 1 - (left - 1) + 1;
        if(leftLen >= k) return qchoose(nums, l, left, k); // k小在左侧
        else if(c + b >= k ) return key; // 在中间，中间值均为key
        else return qchoose(nums, right, r, k - a -b); // k小在右侧
        
        // // 一、返回第k大
        // 2 选择性递归[l, left][left + 1, right -1][right, r]
        int rightLen = r - right + 1
        int midLen = right - 1 - (left - 1) + 1;
        if(rightLen >= k) return qchoose(nums, l, left, k); // k大在右侧
        else if(c + b >= k ) return key; // 在中间，中间值均为key
        else return qchoose(nums, l, left, k - a -b); // k小在左侧
        
    }
    int getKey(vector<int>&nums, int l, int r){
        return nums[rand() % (right - left + 1) + left];
    }
};
```

* 堆排序解决topk

```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        priority_queue<int, vector<int>, greater<int>> minheap;
        // 堆中先构造k个元素
        int i = 0;
        for(; i < k; ++i){
            minheap.push(nums[i]);  // 最小的元素在上边
        }
        
        // 将k后的元素与堆中最小值进行替换
        // 最后保证小根堆中是最大的k个元素，堆顶是第k大
        for(i; i < nums.size(); ++i){
            if(nums[i] > minheap.top()){
                minheap.pop();
                minheap.push(nums[i]);
            }
        }

        return minheap.top();
    }
};
```

* 前k个元素

```cpp
class Solution {
public:
    vector<int> smallestK(vector<int>& arr, int k) {
        srand(time(NULL));
        int len = arr.size();
        qSortChoose(arr, 0, len-1, k);
        // 前k小
        return {arr.begin(), arr.begin() + k};
        // 前k大
        return {arr.begin() + arr.size() - k, arr.end()}
    }
    void qSortChoose(vector<int>& arr, int l, int r, int k){
        if(r <= l) return;
        int key = getKey(arr, l, r);

        // 三个指针
        int i = l, left = l - 1, right = r + 1;
        while(i < right){
            if(arr[i] < key) swap(arr[++left],arr[i++]);
            else if(arr[i] == key) i++;
            else swap(arr[i], arr[--right]);
        }

        // 一、前k小
        // 判断递归 [l, left][left+1, right-1][right,r]
        int a = left - l + 1;
        int b = right - 1 - left;
        if(a >= k) qSortChoose(arr, l, left, k); // 左区间寻找
        if( a + b >= k ) return ;
        else qSortChoose(arr,right, r, k - a - b );
        
        // 二、前k大
        int rightLen = r - right + 1
        int midLen = right - 1 - (left - 1) + 1;
        if(rightLen >= k) return qchoose(nums, l, left, k); // k大在右侧
        else if(c + b >= k ) return ; // 在中间，中间值均为key
        else return qchoose(nums, l, left, k - a -b); // k小在左侧

    }
    int getKey(vector<int>&arr, int left, int right){
        return arr[rand() % (right - left + 1) + left];
    }
};
```

# 归并排序

* 快排相当于树的前序遍历，处理根左右
* 归并排序相当于树的后序遍历，处理左右根
* 流程：
  1. 根据中间节点分为两个部分，两个部分分别归并排序（左右）
  2. 排序完成后合并操作，保存在tmp容器中（根）
  3. 将tmp数据迁移到原nums中

```cpp
//3-22
// 归并排序
class Solution {
    vector<int> tmp;
public:
    vector<int> sortArray(vector<int>& nums) {
        tmp.resize(nums.size());
        merageSort(nums, 0, nums.size() -1);
        return nums;

    }
    void merageSort(vector<int>& nums, int l, int r){
        if(r <= l ) return;  // 判断边界
        // 1 关键key
        int mid = (r + l) >> 1;
        // 2 左右两端分开排序
        merageSort(nums, l, mid);
        merageSort(nums, mid + 1, r);

        // 3 合并到tmp
        int cur1 = l, cur2 =mid+1, i=0;
        while(cur1 <= mid && cur2 <= r) {
            tmp[i++] = nums[cur1] <= nums[cur2] ? nums[cur1++] : nums[cur2++];
        }
        // 没有合并完的继续
        while(cur1 <= mid) tmp[i++] = nums[cur1++];
        while(cur2 <= r) tmp[i++] = nums[cur2++];

        // 4 tmp迁移到nums
        for(int i = l;i <= r; i++){
            nums[i] = tmp[i - l];
        }


    }
};

```

# 基本算术

## 求和

--- 位运算

```cpp
class Solution {
public:
    int getSum(int a, int b) {
        while(b != 0){
            // 无进位相加
            int sum = a ^ b;
            // 求进位
            int car = (a & b) << 1;
            a = sum;
            b = car;
        }
        return a;

    }
};
```



## 求积

--- 位运算



## 求幂

--- 递归--快速幂

```cpp
// n>=0
double pow(double x, int n){
    // 出口
    if(n == 0) return 1;
    
    // 子问题
    double tmp = pow(x, n / 2);
    return n % 2 == 0 ? tmp * tmp : tmp * tmp * x;
}

// n < > 0 且 n非常大
double myPow(double x, int n)
{
    return n > 0 ? pow(x. (long long)n) : 1 / pow(x, -(long long)n);
}
double pow(double x, long long n)
{
    if(n == 0) return 1;
    
    double tmp = pow(x, n / 2);
    return n % 2 == 0 ? tmp * tmp : tmp * tmp * x;
}
```



# 递归

核心：找到两个对象相互操作

1. 根据递归子问题，设计出递归函数的函数**传入参数**，**是否有返回值**
   * 递归子问题：从除开第一次递归的某次==具体的子过程==中抽象出来
   * 若递归函数有返回值，则函数体中需要2个返回值
   * 1个操作后的返回值，第2个是递归出口（边界情况）的返回值
2. 将==某种操作==具体的表现出来，得到递归函数体
   * 某一个==具体==的对象，和某一个==抽象==的对象（需要递归的部分）进行某种操作
3. 递归函数出口：判断什么情况下不需要再分子问题，即某次的操作不符合设定的操作，经过处理后，==return==

## 1 链表递归

| 题目                                                         | 递归子问题（某次递归具体的操作）               | 出口                     |
| ------------------------------------------------------------ | ---------------------------------------------- | ------------------------ |
| [汉诺塔](https://leetcode.cn/problems/hanota-lcci/submissions/515342701/) | 将A柱上的N个盘子借助B放到C上                   | A上盘子直接放到C上       |
| [合并有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/) | 合并链表，找到头节点，链接上其余其余节点       | 某条链为空，则返回另一条 |
| [反转链表](https://leetcode.cn/problems/reverse-linked-list/description/) | 将第一个后面的节点全部逆置后，连接上第一个节点 | 最后一个节点不用逆置     |
| [两两反转链表](https://leetcode.cn/problems/swap-nodes-in-pairs/) | 将前两个后面的互相反，再和前两个链接           | 最后一个不动             |
| [快速幂](https://leetcode.cn/problems/powx-n/)               |                                                |                          |

【汉诺塔】

<img src="https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240322220303724.png" alt="image-20240322220303724" style="zoom:67%;" />

```cpp
class Solution
{
public:
     void hanota(vector<int>& a, vector<int>& b, vector<int>& c)
     {
        dfs(a, b, c, a.size());
     }
     void dfs(vector<int>& a, vector<int>& b, vector<int>& c, int n)
     {
         // 出口
        if(n == 1)
        {
            c.push_back(a.back());
            a.pop_back();
            return;
        }
         // 具体部分子问题
        dfs(a, c, b, n - 1);
        c.push_back(a.back());
        a.pop_back();
        dfs(b, a, c, n - 1);
     }
};
```

【合并有序链表】

<img src="https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240322220409068.png" alt="image-20240322220409068" style="zoom:67%;" />

```cpp
class Solution
{
public:
     ListNode* mergeTwoLists(ListNode* l1, ListNode* l2)
     {
         // 出口
         if(l1 == nullptr) return l2;
         if(l2 == nullptr) return l1;
         
         // 子问题
         if(l1->val <= l2->val)
             {
             	l1->next = mergeTwoLists(l1->next, l2);
             	return l1;
             }
         else
         {
         	l2->next = mergeTwoLists(l1, l2->next);
         	return l2;
         }
     }
};

```

【反转链表】

<img src="https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240322220505550.png" alt="image-20240322220505550" style="zoom:50%;" />

```cpp
class Solution
{
public:
     ListNode* reverseList(ListNode* head) 
     {
         // 出口
         if(head == nullptr || head->next == nullptr) return head;
         
         // 子问题
         ListNode* newHead = reverseList(head->next);
         head->next->next = head;
         head->next = nullptr;
         return newHead;
     }
};

```



【两两反转】

<img src="https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240322220724085.png" alt="image-20240322220724085" style="zoom:50%;" />

```cpp
class Solution
{
     public ListNode reverseList(ListNode *head) 
     {
         if(head == null || head.next == null) return head;
         ListNode *newHead = reverseList(head->next->next);
         ListNode *ansNode = head->next;
         ansNode->next = head;
         head->next = newHead;
         return ansNode;
     }
}

```



【快速幂】

<img src="https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240323100052169.png" alt="image-20240323100052169" style="zoom:33%;" />



```cpp
// n < > 0 且 n非常大
double myPow(double x, int n)
{
    return n > 0 ? pow(x. (long long)n) : 1 / pow(x, -(long long)n);
}
double pow(double x, long long n)
{
    if(n == 0) return 1;
    
    double tmp = pow(x, n / 2);
    return n % 2 == 0 ? tmp * tmp : tmp * tmp * x;
}
```





## 2 二叉树深搜

核心：理解为 根节点+左右孩子节点之间的操作

1. 找到合适的深搜方式：前序遍历、中序遍历、后序遍历
2. 对左右子树使用递归，处理子问题
3. 对根进行具体的操作
4. 递归的出口一般是叶子节点

| 题目                                                         | 解析                                   |
| ------------------------------------------------------------ | -------------------------------------- |
| // 函数体中判断：某个节点                                    |                                        |
| [计算bool二叉树的值](https://leetcode.cn/problems/evaluate-boolean-binary-tree/) | root树是true还是false，返回bool        |
| [根节点到叶子节点路径数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/description/) | root树的根节点到叶子节点的路径数字和   |
| [二叉树剪枝](https://leetcode.cn/problems/binary-tree-pruning/submissions/515533783/) | root树是不是要剪掉，剪掉return nullptr |
| [找二叉搜索树中的第k小](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/) | (全局变量) 返回中序遍历的第k个元素     |
| [判断是否为二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/) | root树是否为搜索二叉树 （全局变量）    |
|                                                              |                                        |



## 3 二叉树回溯

* 解决排列、组合、路径搜索问题

1. 回溯方式：
   * 借助全局变量
   * 借助函数形参

| 题目                                                         | 解析                       |
| ------------------------------------------------------------ | -------------------------- |
| [二叉树到叶子节点所有路径](https://leetcode.cn/problems/binary-tree-paths/) | 使用==局部变量==，还原现场 |



# 树

1. 函数体：找到合适dfs顺序，对子树递归（
   * 直接对子树递归   
   * 在root内对树递归
2. 递归出口：
   * `root == nullptr` 深搜出口
   * ``root->next == nullptr`

## 1 普通二叉树

| 题目                                                         | 解析                                 |
| ------------------------------------------------------------ | ------------------------------------ |
| [计算bool二叉树的值](https://leetcode.cn/problems/evaluate-boolean-binary-tree/description/) | （直接）后续遍历                     |
| [去除val为0的子树](https://leetcode.cn/problems/binary-tree-pruning/) | （在树内）后续遍历 + 剪枝            |
| [根节点到叶节点的所有路径](https://leetcode.cn/problems/binary-tree-paths/) | 前序遍历 + 形参自动回溯              |
| [根节点到叶节点的数值和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/) | 前序遍历 + 形参自动回溯 （原理相同） |

【计算bool二叉树值】

![image-20240710234736425](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240710234736425.png)

```cpp
class Solution {
public:
    bool evaluateTree(TreeNode* root) 
    {
        
        if(root->left == nullptr) return root -> val == 0 ? false : true;
        
        bool left = evaluateTree(root->left);
        bool right = evaluateTree(root->right);
        return root -> val == 2? left | right : left & right;
        
    }
};
```



【去除val为0的子树】

![image-20240710235732091](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240710235732091.png)

```cpp
class Solution {
public:
    TreeNode* pruneTree(TreeNode* root) {
        
        if(root == nullptr) return root;
        root -> left = pruneTree(root->left);
        root -> right = pruneTree(root->right);
        if(root ->left == nullptr && root ->right == nullptr && root->val == 0)
        {
            delete root;
            root = nullptr;
        }
        return root;
    }
};
```

【根节点到叶节点路径】

```cpp
class Solution {
public:
    vector<string> ans;
    vector<string> binaryTreePaths(TreeNode* root) {
        string path = "";
        dfs(root, path);
        return ans;

    }
    // 前序遍历 + 形参保存现场
    void dfs(TreeNode* root, string path)
    {
        if(root == nullptr) return;
        path += to_string(root->val);
        // 遇到叶子节点，保存路径
        if(root->left == nullptr && root->right==nullptr)
        {
            ans.push_back(path);
        }
        else
        {
            path += "->";
        }
        if(root->left) dfs(root->left, path);
        if(root->right) dfs(root->right, path);
    }
};
```



【根节点到叶节点数值和】

```cpp
class Solution {
public:
    int ans = 0;
    int sumNumbers(TreeNode* root) {
        string path = "";
        dfs(root, path);
        return ans;
    }
    void dfs(TreeNode* root, string path)
    {
        if(root == nullptr) return;
        
        // 遇到叶子节点，保存路径字符串，再转为int求和
        if(root->left ==nullptr && root->right==nullptr)
        {
            path += to_string(root->val);
            ans += std::stoi(path);
        }
        else
        {
            path += to_string(root->val);
        }
        if(root->left) dfs(root->left, path);
        if(root->right) dfs(root->right, path);
    }
};
```



## 2 搜索二叉树

1. 利用特性：==中序遍历结果有序==
2. 使用==全局变量==保存遍历的前一个结果

| 题目                                                         | 解析                    |
| ------------------------------------------------------------ | ----------------------- |
| [判断是否为搜索二叉树](https://leetcode.cn/problems/validate-binary-search-tree/) | 中序遍历特性 + 全局变量 |
| [二叉搜索树的第k小元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/description/) | 中序遍历特性 + 全局变量 |
|                                                              |                         |

【判断搜索二叉树】

```cpp
class Solution {
public:
    long pre = LONG_MIN;
    // 前序遍历
    bool isValidBST(TreeNode* root) {
        if (root == nullptr) return true;

        // 检查左子树
        if (!isValidBST(root->left)) return false;

        // 检查当前节点
        if (root->val <= pre) return false;
        pre = root->val;

        // 检查右子树
        if (!isValidBST(root->right)) return false;

        return true;
    }
};
```

【找到第k小的数】

```cpp
class Solution {
public:
    int count;
    int ans = 0;
    int kthSmallest(TreeNode* root, int k) {
        count = k;
        dfs(root);
        return ans;
    }
    // 前序遍历得到有序数组，找到第k个
    void dfs(TreeNode* root)
    {
        if(root == nullptr) return;
        dfs(root->left);
        
        count--;
        if(!count) 
        {
            ans = root->val;
            return;
        }
        dfs(root->right);
    }
};
```

## 层次遍历





# 动态规划

## 股票买卖

一天的三种状态‘ ： 持仓、 空闲、 冷冻

| 问题          | 1    |
| ------------- | ---- |
| 手续费        |      |
| 冷冻期        |      |
| 只允许交易k次 |      |

【手续费】

<img src="https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240325000650843.png" alt="image-20240325000650843" style="zoom:50%;" />

```cpp
// 3-25
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        vector<vector<int>>dp(n, vector<int>(2));

        dp[0][0] = -prices[0] - fee;
        for(int i = 1; i < n; ++i){
            // 持仓
            dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[i]-fee);
            // 空闲
            dp[i][1] = max(dp[i-1][1], dp[i-1][0]+prices[i]);
        }
        return max(dp[n-1][0], dp[n-1][1]);

    }
};
```



【冷冻期】

<img src="https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240324235923923.png" alt="image-20240324235923923" style="zoom:50%;" />

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // dp表，三种状态
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(3));

        dp[0][0] = -prices[0];
        for(int i = 1; i < n; ++i){
            // 持仓
            dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[i]);
            // 空闲
            dp[i][1] = max(dp[i-1][2], dp[i-1][1]);
            // 冷冻
            dp[i][2] = dp[i-1][0] + prices[i];
            
        }
        return max(dp[n-1][1], dp[n-1][2]);


    }
};
```



【交易k次】

状态表：三维数组 [天数] [状态] [交易次数]

将1个三维数组，转换为两个2维数组

```cpp
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        int n = prices.size();
        const int MIN = -0x3f3f3f3f;
        // 最多交易k次， 加上0，有k+1次状态
        vector<vector<int>> f(n, vector<int>(k+1, MIN)); // 持仓
        auto g = f; // 空闲

        // 初始化
        f[0][0] = -prices[0];
        g[0][0] = 0;

        // 状态方程
        for(int i = 1; i < n; ++i){
            // 根据次数再次填充
            for(int j = 0; j < k+1; j++){
                f[i][j] = max(f[i-1][j], g[i-1][j] - prices[i]);
                // 判断j为0，即第i天都没有交易过，所以不存在持仓到空闲的转换
                if(j == 0) g[i][j] = g[i-1][j];
                else g[i][j] = max(g[i-1][j], f[i-1][j-1] + prices[i]);
            }
        }

        // 返回值
        int ret = MIN;
        for(auto p : g[n-1]){
            ret = max(ret, p);
        }
        return ret;

    }
};
```





## 回文串

| 题目                                                         | 解决                                 |
| ------------------------------------------------------------ | ------------------------------------ |
| [回文子串的个数](https://leetcode.cn/problems/palindromic-substrings/submissions/516429663/) | 统计dp表中true的个数                 |
| [最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/description/) | 变量保存回文串的长度                 |
| [分割三块子串是否为回文串](https://leetcode.cn/problems/palindrome-partitioning-iv/submissions/516675056/) | 统计所有回文串，遍历所有分三块的子串 |
|                                                              |                                      |
|                                                              |                                      |
|                                                              |                                      |
|                                                              |                                      |



1. 从前往后、从后往前读的字符都一样， abba
2. 使用二维dp表，存储 [i,j] 子串是否为回文串， 且使用二维表的上三角区域存储
3. 状态转移方程：判断前后字符一样的情况下，判断内部子串是否为回文串

```cpp
class Solution {
public:
    int countSubstrings(string s) {
        // 存储是否为回文子串
        int n = s.size();
        vector<vector<bool>> dp(n, vector<bool>(n, false));

        // 状态转移方程+填表顺序  --. 从下往上
        int num = 0;
        for(int i = n -1; i >=0 ; --i){
            for(int j = i; j < n; ++j){
                // 判断前后元素相等，继而判断中间元素回文
                if(s[i] == s[j]) dp[i][j] = ((i == j )|| (i+1 == j)) ? true : dp[i+1][j-1];
                if(dp[i][j] == true) num++;
            }        
        }
        return num;

    }
};
```

## 子数组

| 题目                                                         | 求解                            |
| ------------------------------------------------------------ | ------------------------------- |
| [最大子数组和](https://leetcode.cn/problems/maximum-subarray/) | 以i为结尾的所有子数组中的最大和 |
| [环形数组下的最大子数组和](https://leetcode.cn/problems/maximum-sum-circular-subarray/) | 转换为求最小子数组和            |
| [最大子数组乘积](https://leetcode.cn/problems/maximum-product-subarray/submissions/516759976/) | 注意i位置的正负的最大值计算方法 |
| [乘积为正数的最长子数组](https://leetcode.cn/problems/maximum-length-of-subarray-with-positive-product/description/) | 区分num[i]为正负0的三种情况     |



​	

# 总结

## 1 递归、循环、深搜

1. 深度优先遍历 ： 前序遍历、 中序遍历、后序遍历

2. 递归的展开图本质是对数的深度优先遍历

3. 递归和循环都是解决同一类问题，因此，递归和循环可以转换

   当递归树复杂，多叉时候，递归方便，当递归树单支，循环方便

<img src="https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures/img/202407091354365.png" alt="image-20240709135442968" style="zoom:50%;" />

# 章节分类

## 1 数组

| 题目                | 解法         |
| ------------------- | ------------ |
| 快乐数              | 快慢指针     |
| 两数之和【求下标】  | 哈希表       |
| 两数之和【求值】    | 对撞指针     |
| 三数之和【求值】    | 对撞指针     |
| 长度最小的子数组    | 滑动窗口     |
| 水果成篮            | 滑动窗口     |
| 有重复值的第K大元素 | 三段快速选择 |
| 有重复值的前K大元素 | 三段快速选择 |



## 2 链表

## 3 字符串

1. 创建`arr[128]`充当哈希表，记录某个字符是否存在

| 题目                 | 解法     |
| -------------------- | -------- |
| 无重复字符的最长子串 | 滑动窗口 |



### 4 树

