[霍丙乾渡劫c++协程](https://www.bennyhuo.com/book/)

[搜狗WorkFlow框架](https://github.com/sogou/workflow/blob/master/README_cn.md)

# 一 异步线程数据同步

## 1 promise<>

`std::promise<int>`用于存储一个 `int` 类型的值或异常，用于在异步编程中同步数据。

它常与 `std::future<int>` 和 `std::packaged_task<int()>` 一起使用，一个线程通过`std::promise`设置值或异常，另一个线程通过`std::future`获取这个值或等待异常。

需要注意的是，`std::promise`对象只能使用一次来设置值或异常，一旦设置完成，就不能再次设置。

|                 接口                  |                             描述                             |
| :-----------------------------------: | :----------------------------------------------------------: |
|            `get_future()`             | 获取一个与当前`std::promise`对象关联的`std::future`对象。这个`std::future`对象可以用来在其他线程中同步获取`std::promise`所设置的值或异常。 |
|      `set_value(const T& value)`      | 为关联的`std::future`对象设置值。`T`是`std::promise`模板参数指定的类型。调用此函数后，任何等待该`std::future`对象`get()`方法的线程将会收到这个值并继续执行。 |
|        `set_value(T&& value)`         | 以右值引用的方式为关联的`std::future`对象设置值。这是一种移动语义的赋值方式，通常用于优化性能，避免不必要的拷贝操作。 |
| `set_exception(std::exception_ptr p)` | 为关联的`std::future`对象设置异常。`std::exception_ptr`是一个可以持有异常对象的指针。当调用`std::future`的`get()`方法时，如果`std::promise`设置了异常，那么这个异常将被重新抛出。 |



## 2 future<>

|                             接口                             |                             描述                             |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
|                           `get()`                            | 获取与`std::future`对象关联的异步任务的结果。如果结果尚未准备好，该函数将阻塞当前线程，直到结果准备好为止。如果异步任务抛出了异常，`get()`函数将重新抛出该异常。 |
|                           `wait()`                           | 等待与`std::future`对象关联的异步任务完成。该函数将阻塞当前线程，直到异步任务完成。它不返回结果，也不抛出异常，只是简单地等待任务完成。 |
|   `wait_for(std::chrono::duration<Rep, Period> rel_time)`    | 等待与`std::future`对象关联的异步任务完成，但最多只等待指定的相对时间。如果在指定的时间内任务完成，函数将返回`std::future_status::ready`；如果超时但任务未完成，则返回`std::future_status::timeout`；如果任务已被取消或设置了异常，则返回`std::future_status::deferred`。 |
| `wait_until(std::chrono::time_point<Clock, Duration> abs_time)` | 等待与`std::future`对象关联的异步任务完成，但最多只等待到指定的绝对时间点。如果在指定的时间点之前任务完成，函数将返回`std::future_status::ready`；如果超时但任务未完成，则返回`std::future_status::timeout`；如果任务已被取消或设置了异常，则返回`std::future_status::deferred`。 |
|                          `valid()`                           | 检查`std::future`对象是否有效。如果对象是通过有效的`std::promise`对象或`std::async`函数创建的，则返回`true`；否则返回`false`。 |

这些接口提供了对异步任务结果的访问和同步机制。通过`get()`函数，可以获取异步任务的结果；通过`wait()`、`wait_for()`和`wait_until()`函数，可以等待异步任务完成或超时；通过`valid()`函数，可以检查`std::future`对象的有效性。这些接口通常与`std::promise`或`std::async`一起使用，以实现线程间的异步编程和同步机制。

## 3 egg

```cpp
#include <iostream>  
#include <thread>  
#include <future>  
  
void threadFunction(std::promise<int>&& prom) {  
    // 模拟一些工作  
    std::this_thread::sleep_for(std::chrono::seconds(1));  
      
    // 设置 promise 的值  
    prom.set_value(42);  
}  
  
int main() {  
    // 创建一个 promise 对象  
    std::promise<int> prom;  
      
    // 从 promise 对象获取一个 future 对象  
    std::future<int> fut = prom.get_future();  
      
    // 创建一个线程来运行 threadFunction，并将 promise 移动给它  
    std::thread t(threadFunction, std::move(prom));  
      
    // 阻塞，直到 prom.set_value() 被调用
    int value = fut.get(); 
      
    // 输出从 future 获取的值  
    std::cout << "Value: " << value << std::endl;  
      
    // 等待线程完成  
    t.join();  
      
    return 0;  
}
```

## 4 传统异步编程

多线程 + 回调函数 + 条件变量

```cpp
#include <iostream>
#include <thread>
#include <functional>
#include <condition_variable>
#include <mutex>

// 模拟耗时操作
void performTask(std::function<void(int)> callback) {
    std::cout << "Task started, processing...\n";
    std::this_thread::sleep_for(std::chrono::seconds(2));  // 模拟耗时操作
    int result = 42;  // 假设处理结果为42
    callback(result);  // 调用回调函数并传递结果
}

// 回调函数
void onTaskCompleted(int result, std::condition_variable &cv, bool &done) {
    std::cout << "Task completed with result: " << result << "\n";
    // 通知主线程任务完成
    {
        std::lock_guard<std::mutex> lock(mtx);
        done = true;
    }
    cv.notify_one();
}

// 互斥量和条件变量
std::mutex mtx;
std::condition_variable cv;

int main() {
    bool done = false;
    
    std::cout << "Starting task...\n";
    // 创建线程执行异步任务，并传递回调函数
    std::thread t(performTask, std::bind(onTaskCompleted, std::placeholders::_1, std::ref(cv), std::ref(done)));
    t.detach();  // 分离线程，允许它在后台运行

    // 等待异步任务完成
    {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, [&done] { return done; });
    }

    std::cout << "Task is running asynchronously.\n";
    std::cout << "Main thread finished.\n";
    return 0;
}

```







# 二 协程

[参考博客](https://zplutor.github.io/2022/03/25/cpp-coroutine-beginner/)

## 0 协程框架

### 0.1 代码总览

* 可在项目中修改使用

```cpp
#include <iostream>
#include <coroutine>
#include <thread>
#include <chrono>

// 定义一个简单的协程返回类型
struct MyCoroutine {
    struct promise_type;
    using handle_type = std::coroutine_handle<promise_type>;

    struct promise_type {
        auto get_return_object() {
            // 返回句柄，外部控制
            return MyCoroutine(handle_type::from_promise(*this));
        }
        
        std::suspend_always initial_suspend() { return {}; }  // 协程开始执行时挂起，通过handle外部唤醒执行
        std::suspend_always final_suspend() noexcept { return {}; }  // 退出挂起，通过外部唤醒结束
        void return_void() {}
        void unhandled_exception() { std::terminate(); }
    };

    handle_type coro;

    MyCoroutine(handle_type h) : coro(h) {}
    ~MyCoroutine() { if (coro) coro.destroy(); }

    // 外部控制协程的唤醒执行
    void resume() { coro.resume(); }
};

// 定义一个awaitable对象
struct Awaitable {
    bool await_ready() const noexcept { 
        return false; // 总是挂起
    }

    void await_suspend(std::coroutine_handle<> h) const noexcept {
        std::this_thread::sleep_for(std::chrono::seconds(1)); // 模拟一些异步操作
        h.resume();  // 
    }

    int await_resume() const noexcept {
        return 42; // 恢复时返回一个值
    }
};

// 协程
MyCoroutine my_coroutine() {
    std::cout << "Before co_await" << std::endl; // 执行
    int result = co_await Awaitable{};           // 参考流程
    std::cout << "After co_await, result = " << result << std::endl;
}

int main() {
    MyCoroutine myCoro = my_coroutine();
    myCoro.resume(); // 启动协程
    std::this_thread::sleep_for(std::chrono::seconds(2)); // 主线程等待，以便看到完整输出
    return 0;
}
```

### 0.2协程执行流程

* `MyCoroutine myCoro = my_coroutine(); `

1. 开辟堆空间
2. 栈空间向堆空间拷贝状态信息
3. 创建promise对象
4. 创建协程返回值` MyCoroutine`，`p.get_return_object()`,获取到`handle`

5. 判断协程执行前是否挂起`p.initial_suspend()`

---------------

![](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures/img/202406051203965.png)

* . `initial_suspend()`不挂起：直接执行协程体

```cpp
std::cout << "Before co_await" << std::endl; // 执行
int result = co_await Awaitable{};           // 执行

```

* 执行`co_await`判断`await_ready()`是否在执行 `co_await` 表达式时是否需要挂起协程。

1.  挂起：不阻塞主函数，执行co_suspend()

```cpp
void await_suspend(std::coroutine_handle<> h) const noexcept {
        std::this_thread::sleep_for(std::chrono::seconds(1)); // 模拟一些异步操作
        h.resume();  // 执行完毕后，唤醒
}

// 执行await_resume，赋值给result

// co_await执行完毕
std::cout << "After co_await, result = " << result << std::endl;// 开始执行
```

2. 不挂起：继续执行协程，跳过 suspend

![image-20240605120538661](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures/img/202406051205965.png)



* `initial_suspend()`挂起：不阻塞主函数

```cpp
std::cout << "Before co_await" << std::endl; // 执行
int result = co_await Awaitable{};           // 执行
```

1 判断await_ready()

同上

---------------------------------------

主函数继续执行，协程流程如下：

1. 协程体结束，调用`co_return`返回结果，通过`p.return_value()`将结果存入promise给外部调用，结束协程
2. 协程体结束，调用`co_return`返回空结果，通过`p.return_void`结束协程
3. co_yield返回结果后挂起
4. 协程结束后判断是否挂起(final_suspend)，否则直接结束，释放资源

![img](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures/img/202404241051077.png)

## 1 协程概念

在没有协程的时代，为了应对 IO 操作，主要有三种模型

- **同步编程**：应用程序等待IO结果（比如等待打开一个大的文件，或者等待远端服务器的响应），阻塞当前线程；
- 优点：符合常规思维，易于理解，逻辑简单；
- 缺点：成本高昂，效率太低，其他与IO无关的业务也要等待IO的响应；
- **异步多线程/进程**：将IO操作频繁的逻辑、或者单纯的IO操作独立到一/多个线程中，业务线程与IO线程间靠通信/全局变量来共享数据；
- 优点：充分利用CPU资源，防止阻塞资源
- 缺点：线程切换代价相对较高，异步逻辑代码复杂
- **异步消息+回调函数**：设计一个消息循环处理器，接收外部消息（包括系统通知和网络报文等），收到消息时调用注册的回调函数；
- 优点：充分利用CPU资源，防止阻塞资源
- 缺点：代码逻辑复杂

协程的概念，从一定程度来讲，可以说是**“用同步的语义解决异步问题”**，即业务逻辑看起来是同步的，但实际上并不阻塞当前线程（一般是靠事件循环处理来分发消息）。协程就是用来解决异步逻辑的编程复杂度问题的。

### **优点**

- 协程更加轻量，创建成本更小，降低了内存消耗
- 协程有自己的调度器，减少了 CPU 上下文切换的开销，提高了 CPU 缓存命中率
- 减少同步加锁，整体上提高了性能
- 可以按照同步思维写异步代码，即用同步的逻辑，写由协程调度的回调

### **缺点**

- 在协程执行中不能有阻塞操作，否则整个线程被阻塞
- 协程可以处理 IO 密集型程序的效率问题，但不适合处理 CPU 密集型问题

### **适用场景**

- 高性能计算，牺牲公平性换取吞吐。
- 在 IO 密集型的热舞
- Generator 式的流式计算

协程可以被认为是一种轻量级的线程，但是它们的调度完全由程序员控制，而不是由操作系统内核进行管理。

与线程相比，协程的创建、销毁和切换开销都更小，因此它们更适合于某些特定的异步编程场景。

## 2 协程实现

`普通函数`：停止后，线程函数栈上的数据清空，重新执行函数时候，从头后开始执行

`协程`是一个函数，将线程栈上的数据在堆上保存，停止后，栈上的数据清空，继续执行函数，从堆上获取数据到栈上，实现从停止的位置继续执行

C++20引入关键字 `co_await` 、`co_return` 和 `co_yield`

**只要在普通函数体内使用关键字其中一个，这个函数就会被编译器按照协程编译**

| 关键字      | 作用                                                         |
| ----------- | ------------------------------------------------------------ |
| `co_await`  | 让协程暂停下来（挂起），主线程继续往下执行，协程等待某个操作完成之后再恢复执行 |
| `co_return` | 协程结束，返回协程的执行结果，类似return返回函数结果         |
| `co_yieled` | 多次返回协程的结果，并且让协程暂停，然后等下一次机会恢复执行 |

### 2.1 co_await

* 暂停协程, 执行操作，返回执行结果

* 使用`co_await`需要遵循`awaitable`设计原则，即等待体需要实现三个操作函数
* 作用于对象（等待体），等待体需要实现三个成员函数，顺序调用三个函数

| 函数                       | 功能                                                       |
| -------------------------- | ---------------------------------------------------------- |
| `await_ready` ，`返回bool` | `true`:不用挂起`false`:挂起                                |
| `await_suspend`，`void`    | 线程执行协程暂停后的操作，执行完毕后唤醒协程(注册回调函数) |
| `await_resume`，T          | 返回协程唤醒后，co_await的执行操作的结果T                  |

```cpp
// 协程
Task PrintInt() {

    IntReader reader1;
    int total = co_await reader1;  // 协程暂停等待操作完成，后唤醒协程，获取操作执行结果

    IntReader reader2;
    total += co_await reader2;
    
    std::cout << total << std::endl;
}
```

```cpp
// 等待体
class IntReader {
public:
    // 判断是否需要暂停协程
    bool await_ready() {
        return false; // 永远暂停
    }

    // co_await暂停时候，自动传入该协程的句柄
    void await_suspend(std::coroutine_handle<> handle) {

        std::thread thread([this, handle]() {

            static int seed = 0;
            value_ = ++seed;

            // 通过句柄唤醒协程
            handle.resume();
            });

        thread.detach();
    }

    // 获取co_await后执行的结果
    int await_resume() {
        return value_;
    }

private:
    int value_{};
};
```

------

* c++20预置两个等待体模型

* 顾名思义，这两个类型分别表示“不暂停”和“要暂停”，实际上它们的区别仅在于 `await_ready()` 函数的返回值， `std::suspend_never` 会返回 true，而 `std::suspend_always` 会返回 false。除此之外，这两个类型的 `await_supsend()` 和 `await_resume()` 函数实现都是空的。

  这两个类型是工具类，用来作为 `promise_type` 部分函数的返回类型，以控制协程在某些时机是否要暂停

| 类型                  | 作用                                    |
| --------------------- | --------------------------------------- |
| `std::suspend_never`  | co_await该awaitable对象，协程永久不挂起 |
| `std::suspend_always` | co_await该awaitable对象，协程永久挂起   |

```cpp
struct suspend_always {
 constexpr bool await_ready() const noexcept { return false; }
 constexpr void await_suspend(std::coroutine_handle<>) const noexcept {}
 constexpr void await_resume() const noexcept {}
 };
```

```cpp
 struct suspend_never {
 constexpr bool await_ready() const noexcept { return true; }
 constexpr void await_suspend(std::coroutine_handle<>) const noexcept {}
 constexpr void await_resume() const noexcept {}
 };
```



### 2.2 co_return

* C++对协程的返回类型只有一个要求：包含名为 `promise_type` 的内嵌类型。
* 当协程被调用，在堆上为其状态分配空间的时候，同时会根据 `promise_type` 类创建出一个`promise`实例化对象。
* 协程的返回值并不是在返回之前才创建，而是在协程的创建出一个`promise`实例化对象建出来之后马上就创建的
* 通过`promise_type`内定义的函数，我们可以与协程进行数据交互，以及控制协程的行为。
* `promise_type`类型规定实现的成员函数

| promise_type 默认函数   | 作用                                                         |
| ----------------------- | ------------------------------------------------------------ |
| `value_`                | 用于保存协程的执行结果                                       |
| `initial_suspend()`     | ==返回awaiter==，协程开始执行时的操作（挂起一会or直接执行）  |
| `get_return_object()`   | 生成协程的返回结果对象（协程执行，先生成对象，再填值）       |
| `return_value()`        | 给返回结果赋值，协程结束。调用co_return本质调用该函数        |
| `return_void()`         | 返回空结果，co_return调用                                    |
| `yield_value()`         | 给返回结果赋值,   协程挂起。调用co_yield本质调用该函数       |
| `unhandled_exception()` | 处理异常操作                                                 |
| `final_suspend()`       | ==返回awaiter==协程的结束后执行操作（挂起等待or直接结束释放资源or唤醒父协程实现嵌套） |

```cpp
// 自定义协程返回值类型
// 简单的协程
class Task {
public:
    // ==============================================================
    // 包含规定的内嵌类型，生产promise对象
    class promise_type {
    public:
        promise_type() : value_(std::make_shared<int>()) {}
		// 1 获取协程返回值的对象
        Task get_return_object() { 
            return Task{ value_ };
        }
		
        // 2 协程开始执行时，直接执行，不挂起
        std::suspend_never initial_suspend() { return {}; }
        
        // co_return 10调用
        // 3 给返回值对象赋值10
        void return_value(int value) {
            *value_ = value;
        }
        
        // 4 未定义co_return，则调用返回空
        void return_void() { }
        
        // co_yield调用
        // 5 给返回值对象赋值，返回用就挂机的awaitable对象
        std::suspend_always yield_value(int value) {
            value_ = value;
            return {};
        }
        
        // 6 处理函数异常
        void unhandled_exception() {}

        // 7 协程结束后，直接释放资源，不挂起
        // C++规定 final_suspend() 必须定义成 noexcept ，也就是说它不允许抛出任何异常。
        // 设置挂起后，协程需要通过 coroutine_handle 的 destroy 函数来直接销毁
        std::suspend_never final_suspend() noexcept { return {}; }
	private:
        std::shared_ptr<int> value_;  // 保存协程执行结果
    };
    // ===============================================================

public:
    Task(const std::shared_ptr<int>& value) : value_(value) {}

    int GetValue() const {  // 提供外部接口，获取协程执行结果结果
        return *value_;
    }

private:
    std::shared_ptr<int> value_;  // 获取到promise内部保存的协程结果
};

Task GetInt() {

    IntReader reader1;
    int total = co_await reader1;

    IntReader reader2;
    total += co_await reader2;

    co_return total;  // 本质： promise.return_value(total)
}

int main() {
	
    // 执行协程
    auto task = GetInt();

    std::string line;
    while (std::cin >> line) {
        std::cout << task.GetValue() << std::endl;
    }
    return 0;
}
```

### 2.3 co_yield

当协程调用了 `co_return` ，意味着协程结束了，就跟我们在普通函数中用 `return` 结束函数一样。这时候，与这个协程实例有关的内存都会被释放掉，它不能再执行了。如果需要在协程中多次返回数据而不结束协程的话，可以使用 `co_yield` 操作符。

`co_yield` 的作用是，返回一个数据，并且让协程暂停，然后等下一次机会恢复执行。

 `co_yield value` 这个表达式等价于`co_await promise_type.yield_value(value)`

```cpp
#include <coroutine>
#include <iostream>
#include <thread>

// 一、实现三个函数，满足awaitable的规范要求
// 调用co_await会自动调用三个函数
// 存储协程所要执行的功能函数
class IntReader {
public:
    bool await_ready() {
        return false;
    }

    // co_await暂停时候，自动传入该协程的句柄
    void await_suspend(std::coroutine_handle<> handle) {

        std::thread thread([this, handle]() {

            static int seed = 0;
            value_ = ++seed;

            // 通过句柄唤醒协程
            handle.resume();
            });

        thread.detach();
    }

    // 获取co_await后执行的结果
    int await_resume() {
        return value_;
    }

private:
    int value_{};
};

// 二、协程返回值类型：包含名为 promise_type 的内嵌类型
class Task {
public:
    // ================================================================
    class promise_type {
    public:
        // 生成返回结果
        Task get_return_object() {
            return Task{ std::coroutine_handle<promise_type>::from_promise(*this) };
        }

        std::suspend_always yield_value(int value) {
            value_ = value;
            return {};
        }

        // 返回空函数
        void return_void() { }
        std::suspend_never initial_suspend() { return {}; }
        std::suspend_never final_suspend() noexcept { return {}; }
        void unhandled_exception() {}

        // 得到结果
        int GetValue() const {
            return value_;
        }

    private:
        int value_{};
    };
    // ======================================================================

public:
    Task(std::coroutine_handle<promise_type> handle) : coroutine_handle_(handle) {}

    // 通过句柄直接获取结果
    int GetValue() const {
        return coroutine_handle_.promise().GetValue();
    }

    void Next() {
        coroutine_handle_.resume();  // 手动唤醒协程
    }

private:
    // 操作和管理协程
    std::coroutine_handle<promise_type> coroutine_handle_;
};

// 协程
Task GetInt() {

    while (true) {

        IntReader reader;
        int value = co_await reader;
        co_yield value;  // co_await yield_value(value)  
        // 作用1 给task结果赋值value，可以返回结果   
        // 作用2 生成一个永久挂起的awaitable对象，co_await后，一直挂起，等待手动唤醒
    }
}

int main() {

    auto task = GetInt(); // 执行到co_yield挂起

    std::string line;
    while (std::cin >> line) {

        std::cout << task.GetValue() << std::endl;
        task.Next(); // 唤醒协程，继续执行，更新task
    }
    return 0;
}
```

## 3 协程返回

* 主要解决的就是异步操作的结果值返回

### 3.1 co_await返回

| 函数            | 功能             |
| --------------- | ---------------- |
| `await_ready`   | 协程是否挂起     |
| `await_suspend` | 主要执行异步操作 |
| `await_resume`  | co_await返回值   |

```cpp
int val = co_await co_async(func, arg1, arg2);
```

1. 通过函数co_async将func放入结构体，返回awaitable
2. co_await执行await_suspend将结构体（通过引用传递）传入线程池后，挂起
3. 线程池异步处理func，执行结果传回val，唤醒协程
4. 执行await_resume，传出co_await的结果

![image-20240715113319637](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures/img/202407151133729.png)

### 3.2 Coroutine返回

| 函数                  | 功能                              |
| --------------------- | --------------------------------- |
| `get_return_object()` | 获取结果对象，内部含有val保存结果 |
| `return_value(int x)` | 通过`co_return`给val赋值          |
| `return_void()`       | 返回空                            |
| `val`                 | 保存协程结果                      |
| `get_val`             | 外部接口，获取val                 |

```cpp
// 获取同步结果
Coroutine<int> fun
{
    co_return 2;
}

// 获取异步结果
Coroutine<int> fun
{
    int val = co_await co_async(func, arg1, arg2);
    co_return val;
}

int main()
{
    Corouine<int> ans = fun();
    int a = ans.get_val;
}
```

* 获取异步结果

```cpp
Coroutine<int> fun
{
    co_return 2;
}
int main()
{
    Corouine<int> ans = fun();
    int a = ans.get_val;
}
```



## 4 coroutine_handle

* `std::coroutine_handle<>` 在 C++20 中用于接收一个协程的句柄，操作和管理协程

* 模板参数为promise对象类型，比如：`promise_type`

|              接口函数              |                             描述                             |
| :--------------------------------: | :----------------------------------------------------------: |
|             `resume()`             |      恢复（继续执行）由 `coroutine_handle` 管理的协程。      |
|              `done()`              |          返回一个布尔值，表示协程是否已经完成执行。          |
|            `address()`             |                    返回指向协程帧的指针。                    |
|            `promise()`             | 从句柄获取这个协程的promise对象,可以调用`promise_type`定义的成员函数 |
| `from_promise(promise_t& promise)` |   获取句柄，获取管理该 `promise_t` 的 `coroutine_handle`。   |
|       `from_abi(void* addr)`       | 从 ABI 级别的地址获取 `coroutine_handle`。通常用于底层操作。 |
|            `destroy()`             |           销毁由 `coroutine_handle` 管理的协程帧。           |
|         `operator bool()`          |  返回一个布尔值，表示 `coroutine_handle` 是否有效（非空）。  |
|  `operator*()` 或 `operator->()`   |              解引用操作，用于访问协程帧的成员。              |
| `operator=(coroutine_handle rhs)`  |    赋值操作，将一个 `coroutine_handle` 对象赋值给另一个。    |

1. 大部分的`promise_type`中的`get_return_object()`返回协程生成对象时候，传入句柄，通过句柄，在promise外部对协程进行管理
2. 因此，也不用在结果中设置value获取promise_type的value值，可以通过handle直接获取

```cpp
class Corotinue{
    // promise
    class promise_type{
        Task get_return_object() {
            return Task{ std::coroutine_handle<promise_type>::from_promise(*this) };
        }
    }
    // 构造函数
    Task(std::coroutine_handle<promise_type> handle) : coroutine_handle_(handle) {}
}
// 通过handle唤醒协程
handle.resume();

// 获取promise的value
handle.promise.value_;
       
```



## 5 promise_type

| 对象      | 功能                                                         |
| --------- | ------------------------------------------------------------ |
| `promise` | 调用协程时，根据`promise_type`自动生成，管理协程的数据，如获取协程结果、管理co_return、co_yield |
| `句柄`    | 由`coroutine_handle<>`获取，唤醒协程、销毁协程、获取promise对象、获取句柄 |

promise_type 是连接协程内外的桥梁

**结果类**需要什么，就通过`promise_type`的`get_return_object()`进行获取

### 5.1 唤醒协程

* 法一：等待体内执行`await_suspend()`后唤醒

```cpp
// 默认获取到本协程的句柄
void await_suspend(std::coroutine_handle<> handle) {
    std::thread thread([this, handle]() {

        static int seed = 0;
        value_ = ++seed;

        // 通过句柄唤醒协程
        handle.resume();
        });
```



* 法二：在结果内中通过句柄进行唤醒

```cpp
class Res{
    class promise_type {
    public:
        // 生成返回结果
        Task get_return_object() {
            // 从promise对象中获取到句柄，作为结果的参数
            return Task{ std::coroutine_handle<promise_type>::from_promise(*this) };
        }
    }
    // ====================
public:
    Res(std::coroutine_handle<promise_type> handle) : coroutine_handle_(handle) {}
private:
    // 通过协程外部的句柄管理协程
    std::coroutine_handle<promise_type> coroutine_handle_;
}
```

### 5.2 销毁协程

#### 5.2.1 co_return

协程调用co_return自动销毁协程，及其句柄

**问题：协程和结果类的生命周期不同，当协程外部存在句柄时候，协程销毁后，句柄失效成为野指针**

#### 5.2.2 句柄管理销毁

```cpp
class Res{
    class promise_type {
    public:
        // 生成返回结果
        Task get_return_object() {
            // 从promise对象中获取到句柄，作为结果的参数
            return Res{ std::coroutine_handle<promise_type>::from_promise(*this) };
        }
        
        // 设置协程执行完毕后，永远挂起，通过句柄销毁
        std::suspend_always final_suspend() noexcept { return {}; }

    }
    // ====================
public:
    Res(std::coroutine_handle<promise_type> handle) : coroutine_handle_(handle) {}
    // 同步生命周期，结果析构，释放协程
    ~Res(){coroutine_handle_.destroy()}
private:
    // 通过协程外部的句柄管理协程
    std::coroutine_handle<promise_type> coroutine_handle_;
}
```

**问题：当结果拷贝时，结果析构一份，释放协程，另外的结果句柄变为野指针**

**修改：禁掉左值拷贝，开放右值拷贝，一个结果对应一个协程**

```cpp
class Res {
  ...

  explicit Res(std::coroutine_handle<promise_type> handle) noexcept
      : handle(handle) {}

  Res(Res &&generator) noexcept
      : handle(std::exchange(generator.handle, {})) {}

  Res(Res &) = delete;
  Generator &operator=(Generator &) = delete;

  ~Res() {
    if (handle) handle.destroy();
  }
}

```



## 6 协程嵌套

### 6.1 理解

在一个普通的函数内：

1. 调用到协程，则立刻协程从主函数中分出去，主函数继续往下走

   * 实际上是执行到co_awiat  --  await_suspend（）函数执行完毕后，保存上下文，协程挂起，返回到主函数继续执行

   ```cpp
   Coroutinue fun(){
       co_await body;
   }
   int A()
   {
       Coroutinue<void> res = fun(); // 立刻协程分出去
       B(); // 继续执行
       C();
       
   }
   ```

   

2. 若要等待协程`fun`执行结束后，再继续执行，则`co_await`协程`fun`的结果，本函数变为协程

   ```cpp
   Coroutinue fun(){
       co_await body;
   }
   Coroutinue A()
   {
       auto res = fun(); // 分出去
       B(); // 继续执行
       co_await res; // A变为协程，res的await_suspend执行完毕后挂起
       C(); // 等待唤醒执行
       
   }
   
   Coroutinue D()
   {
       co_await fun(); // 协程分出去，且立即挂起等待协程结束在执行
       B(); 
    
   }
   int func1()
   {
       func();
       A();   // A变为协程，立刻分出去
       func2(); // 继续执行
       D(); // D立即分出去
   }
   ```

3. 获取协程的执行结果value

   * 自己设置的协程内，一般会提供外部接口获取Coroutinue<T>的值

   * [参考代码](###2.2 co_return)

     ```cpp
     void fun
     {
         Coroutine<int> res = func(); // 协程，分出去
         int value = res.getValue(); // 通过接口获取结果value，设计到线程同步问题
     }
     ```

     

     ---

   * 在项目中，Coroutinue并没有设置专门的value保存结果，而是需要在co_await后返回

   ```cpp
   template <typename T>
   struct Coroutine
   {
       using promise_type = PromiseType<T>;
   
       Coroutine(HandleType<T> h) : handle{ h }
       {
       }
   
       bool await_ready()
       {
           return handle.done();
       }
   
       void await_suspend(std::coroutine_handle<> co_handle)
       {
           handle.promise().loopCo.parent_handle = co_handle;
       }
   
       decltype(auto) await_resume()
       {
           // 设置resume，通过await返回最后的结果
            return std::move(handle.promise().value);       
       }
   
   private:
       HandleType<T> handle;
   };
   
   
   
   ```

   ```cpp
   Coroutine<void> fun
   {
       Coroutine<int> res = func(); // func分出去
       int value = co_await res;  // fun挂起，等待func的执行结果，结束后唤醒fun
       // 调用await_resume获取vlue
       co_return; // fun变为协程
   }
   ```


###  6.2 嵌套实现

![image-20240715144017178](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures/img/202407151440275.png)

协程类（返回值）的两大部分：

一、`promise_type`对协程句柄进行管理，包括使用Loop管理、统一销毁协程等

二、`awaitable`，实现嵌套功能，可以被`co_await`作用

```cpp
// 子协程
Coroutine<void> son
{
    co_await co_worker;
    co_return;   // 1 协程执行完毕后，执行funal_suspend,统一销毁子协程  2 唤醒父协程
}
// 父亲协程
Coroutine<void> parent
{
    co_await son;  // 1 将父句柄传递给子协程parent_handle  2 挂起等待唤醒
    co_return;
}
```



##  7 协程终止



# 三 异步任务类

## 3.0 同步阻塞、异步回调

### 3.0.1 概念

![](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures/img/202405071744392.jpg)

**同步阻塞：**

**一个任务的执行会阻塞当前线程A的执行，直到线程B任务完成并返回结果。在当前线程A对结果进行处理。**

在这种模型中，程序会按照顺序执行任务，如果其中一个任务需要等待某些操作的完成，那么当前线程会被阻塞，直到这个任务完成并返回结果。

**异步回调：**

**任务的执行是非阻塞的，当前线程A会继续执行后续代码而不需要等待任务完成。当线程B任务完成后，线程B会调用预先注册的回调函数来处理任务的结果。**

这种模型通常用于处理 I/O 操作、事件处理等需要等待外部资源完成的情况。

### 3.0.2 回调函数原理

```cpp
// 模拟注册回调函数
#include <iostream>
#include <future>

// 异步任务函数，返回一个整数
int simple_task() {
    // 模拟耗时操作
    std::this_thread::sleep_for(std::chrono::seconds(2));
    return 42;
}

int main() {
    // 使用 std::async 启动异步任务
    std::future<int> future_result = std::async(std::launch::async, simple_task);

    // 注册一个回调函数，当异步任务完成时调用
    future_result.then([](std::future<int> future) {
        int result = future.get(); // 获取异步任务的结果
        std::cout << "Task completed with result: " << result << std::endl;
    });

    // 阻塞等待异步任务完成
    future_result.wait();

    return 0;
}

```

在下面的实现中，当**任务完成后能够使用回调函数，是因为任务对象内部维护了一个用于保存回调函数的数据结构 `completion_callbacks`**。当任务完成时，会遍历这个数据结构，依次调用保存的回调函数。

具体来说：

1. 在任务对象的 `on_completed()` 方法中，如果任务已经完成（即 `result` 已经有值），则直接调用传入的回调函数；如果任务尚未完成，则将回调函数添加到 `completion_callbacks` 中。

2. 在任务执行过程中，当任务完成时会设置 `result` 的值，表示任务的执行结果已经准备好。此时，任务对象会遍历保存的回调函数，并依次调用这些回调函数，传入任务的执行结果作为参数。

这样的设计使得任务对象能够灵活地在任务完成后执行一系列的操作，而不需要显式地在每个使用者的代码中处理任务的完成情况。

```cpp
int main() {
  // 协程，不阻塞main
  auto simpleTask = simple_task();
  // 异步回调方法
  // 注册回调
  simpleTask.then([](int i) {
    debug("simple task end: ", i);
  }).catching([](std::exception &e) {
    debug("error occurred", e.what());
  });
    
  // 同步阻塞方法
  try {
    auto i = simpleTask.get_result();
    debug("simple task end from get: ", i);
  } catch (std::exception &e) {
    debug("error: ", e.what());
  }
  return 0;
}
```



## 3.1 promise_type实现 

<img src="https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures/img/202405071744392.jpg" alt="33f9f8fbe1d1c3edee38a08fbadd9fb" style="zoom:67%;" />

* 协程返回值Task内的promise_type
* promise的核心函数
* 同步

| 函数                         | 功能                             |
| ---------------------------- | -------------------------------- |
| `private: value / result`    | 存储协程的结果                   |
| `return_value()`             | 存储结果到value（唤醒）          |
| `get_value() / get_result()` | promise从value中获取结果（阻塞） |

* 异步

| 函数                      | 功能                               |
| ------------------------- | ---------------------------------- |
| `private: value / result` | 存储协程的结果                     |
| `completion_callbacks`    | 回调函数队列                       |
| `return_value()`          | 存储结果到value、执行回调函数      |
| `on_completed()`          | 注册回调函数（加入到回调函数队列） |



```cpp
template<typename ResultType>
struct TaskPromise {
    // 协程立即执行
    std::suspend_never initial_suspend() { return {}; }

    // 执行结束后挂起，等待外部销毁。该逻辑与前面的 Generator 类似
    std::suspend_always final_suspend() noexcept { return {}; }

    // 构造协程的返回值对象 Task,返回协程句柄
    Task<ResultType> get_return_object() {
    return Task{std::coroutine_handle<TaskPromise>::from_promise(*this)};
  	}
    
    // =================================================================
    // 同步阻塞，获取数据
    void return_value(ResultType value) {
        std::lock_guard lock(completion_lock);
        result = Result<ResultType>(std::move(value));
        completion.notify_all();
    }
    
    ResultType get_result() {
        // 如果 result 没有值，说明协程还没有运行完，等待值被写入再返回
        std::unique_lock lock(completion_lock);
        if (!result.has_value()) {
          completion.wait(lock);
    	}
    	// 如果有值，则直接返回（或者抛出异常）
        return result->get_or_throw();
    }

    void unhandled_exception() {
        std::lock_guard lock(completion_lock);
        result = Result<ResultType>(std::current_exception());
        // 通知 get_result 当中的 wait
        completion.notify_all();
    }


private:
    std::optional<Result<ResultType>> result;
    std::mutex completion_lock;
    std::condition_variable completion;
    // =====================================================================
    
    // =====================================================================
    // 异步回调
    void return_value(ResultType value) {
    	std::lock_guard lock(completion_lock);
    	result = Result<ResultType>(std::move(value));
    	completion.notify_all();
        // 调用回调
        notify_callbacks();
  	}
    
    // 判断是否有值，回调处理or注册回调
    void on_completed(std::function<void(Result<ResultType>)> &&func) {
        std::unique_lock lock(completion_lock);
        // 加锁判断 result
        if (result.has_value()) {
          // result 已经有值
          auto value = result.value();
          // 解锁之后再调用 func
          lock.unlock();
          func(value);
        } else {
          // 否则保存回调函数，后续调用
          completion_callbacks.push_back(func);
        }
    }
    
    void unhandled_exception() {
    	std::lock_guard lock(completion_lock);
    	result = Result<ResultType>(std::current_exception());
    	completion.notify_all();
        // 调用回调
        notify_callbacks();
  }
private:
    // 列表，保存回调函数
    std::list<std::function<void(Result<ResultType>)>> completion_callbacks;
  
    void notify_callbacks() {
        auto value = result.value();
        for (auto &callback : completion_callbacks) {
        	callback(value);
    	}
    	// 调用完成，清空回调
    	completion_callbacks.clear();
  	}
```

## 3.2 结果类构建

* 结果类负责与外部函数进行数据交互
* 提供的主要函数

| 函数           | 功能                                                         |
| -------------- | ------------------------------------------------------------ |
| `handle`       | 提供访问协程内部的句柄                                       |
| `get_result()` | 同步阻塞，获取结果类里的数据，调用`handle.promise().get_value()`，后进行处理 |
| `then()`       | 提供回调函数，异步处理协程执行结果（获取+处理结果）          |
| `catching`     | 提供回调函数，异步处理协程的异常（获取+处理异常）            |



```cpp
template<typename ResultType>
struct Task {

    // 声明 promise_type 为 TaskPromise 类型
    using promise_type = TaskPromise<ResultType>;

    // 同步阻塞方式获取result内的值
    // 只获取结果
    ResultType get_result() {
    	return handle.promise().get_result();
    }

	// 异步回调方式获取result内的值
    Task &then(std::function<void(ResultType)> &&func) {
        handle.promise().on_completed([func](auto result) {
            try {
                func(result.get_or_throw());
            } catch (std::exception &e) {
                // 忽略异常
            }
        });
        return *this;
    }

    Task &catching(std::function<void(std::exception &)> &&func) {
        handle.promise().on_completed([func](auto result) {
            try {
                // 忽略返回值
                result.get_or_throw();
                } catch (std::exception &e) {
                    func(e);
                }
            });
            return *this;
        }

    // 协程执行完毕后
    // 直接运行原始的func，不进行异常判断
    Task &finally(std::function<void()> &&func) {
    	handle.promise().on_completed([func](auto result) { func(); });
    	return *this;
    }

    explicit Task(std::coroutine_handle<promise_type> handle) noexcept: 					handle(handle) {}

    Task(Task &&task) noexcept: handle(std::exchange(task.handle, {})) {}

    Task(Task &) = delete;

    Task &operator=(Task &) = delete;

	~Task() {
		if (handle) handle.destroy();
    }

private:
    std::coroutine_handle<promise_type> handle;
};

```

```cpp
void await_suspend(std::coroutine_handle<> handle) noexcept {
    // 当 task 执行完之后调用 resume
    task.finally([handle]() {
      handle.resume();
    });
  }

Task &finally(std::function<void()> &&func) {
    handle.promise().on_completed([func](auto result) { func(); });
    return *this;
  }

// ==================================================================
auto simpleTask = simple_task();
simpleTask.then([](int i) {
	debug("simple task end: ", i);
})
      
Task &then(std::function<void(ResultType)> &&func) {
    handle.promise().on_completed([func](auto result) {
      try {
        func(result.get_or_throw());
      } catch (std::exception &e) {
        // 忽略异常
      }
    });
    return *this;
  }
void on_completed(std::function<void(Result<ResultType>)> &&func) {
    std::unique_lock lock(completion_lock);
    // 加锁判断 result
    if (result.has_value()) {
      // result 已经有值
      auto value = result.value();
      // 解锁之后再调用 func
      lock.unlock();
      func(value);
    } else {
      // 否则添加回调函数，等待调用
      completion_callbacks.push_back(func);
    }
  }
```

## 3.3 结果类转换为等待体

* 为了使结果类也能被`co_await`作用
* 需要使结果类符合`awaitable`规范
* 常用的是，在结果类的`promise_type`中，添加转换函数`await_transform`,将其转换为`awaiter`

| 转换函数            | 功能                                            |
| ------------------- | ----------------------------------------------- |
| `await_transform()` | `co_await Task = coawait await_transform(Task)` |

```cpp
template<typename ResultType>
struct TaskPromise {
  ...

  // 注意这里的模板参数
  template<typename _ResultType>
  TaskAwaiter<_ResultType> await_transform(Task<_ResultType> &&task) {
    return TaskAwaiter<_ResultType>(std::move(task));
  }
  
  ...
}
template<typename R>
struct TaskAwaiter {
  explicit TaskAwaiter(Task<R> &&task) noexcept
      : task(std::move(task)) {}

  TaskAwaiter(TaskAwaiter &&completion) noexcept
      : task(std::exchange(completion.task, {})) {}

  TaskAwaiter(TaskAwaiter &) = delete;

  TaskAwaiter &operator=(TaskAwaiter &) = delete;

  constexpr bool await_ready() const noexcept {
    return false;
  }

  void await_suspend(std::coroutine_handle<> handle) noexcept {
    // 当 task 执行完之后调用 resume
    task.finally([handle]() {
      handle.resume();
    });
  }

  // 协程恢复执行时，被等待的 Task 已经执行完，调用 get_result 来获取结果
  R await_resume() noexcept {
    return task.get_result();
  }

 private:
  Task<R> task;

};

```

#  四 Loop循环调度器

## 4.1 对协程管理

1. 通过 `loop_co`对协程管理
2. 创建协程时，将协程与`loop_co`连接，将`loop_co`加载到`Loop`框架中
3. 通过`Loop`对协程进行统一销毁

```cpp
// 问题
// 协程销毁由Loop管理
// 协程唤醒由谁执行？？？？？
// 换言之，co_awaite waiter中的waiter在哪里定义？
```



# 五 串口通信

## 5.1 概念 

### 1 COM1 

- **串口设备**：`COM1` 代表计算机上的第一个串行通信端口（串口），它是一种用于串行通信的硬件接口，被依次命名为 `COM1`、`COM2`、`COM3` 等
- **历史背景**：串口（COM port，全称 Communication Port）在计算机历史上用于连接各种外围设备，如调制解调器、打印机、鼠标等。串口是一种逐位（bit-by-bit）传输数据的通信接口

### 2 creatFile

在 Windows 系统中，`CreateFile` 函数不仅用于打开文件，还可以用于打开其他设备，包括串口设备。调用 `CreateFile` 并传入串口名称（如 `"COM1"`），可以获取对该串口的访问权限，并返回一个句柄用于后续操作。

打开不同的对象：

* **文件路径**：如 `"C:\\example.txt"`，表示要打开的文件。

* **设备名称**：如 `"COM1"`，表示要打开的串口设备。

* **其他资源**：如 `"\\\\.\\PhysicalDrive0"`，表示要打开的物理磁盘设备。

```cpp
HANDLE h = CreateFile(
    "COM1",                    // 指定了要打开的串口设备
    GENERIC_READ | GENERIC_WRITE, // 访问权限：对该设备进行读写操作
    0,                         // 共享模式：不共享, 即其他进程不能同时访问该串口
    nullptr,                   // 安全属性：使用默认
    OPEN_EXISTING,             // 创建方式：打开现有设备, 而不是创建新设备
    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, // 文件属性和标志：普通属性和重叠（异步）I/O
    nullptr                    // 模板文件：不使用模板
);

if (h == INVALID_HANDLE_VALUE) {
    // 打开失败，处理错误
    DWORD error = GetLastError();
    // 处理错误代码
} else {
    // 打开成功，可以对串口进行读写和配置操作
    // 配置串口超时、波特率等
}
```



## 5.2 通信

### 1 数据帧结构

**串行通信**：数据逐位传输，一次传输一个比特。与并行通信不同，并行通信一次传输多个比特

**数据帧结构**：串口通信中的数据传输以帧为单位，每一帧包括：

- **起始位**：标识数据帧的开始。
- **数据位**：实际传输的数据（通常为5至8位）。
- **校验位**：用于检测传输错误（可选）。
- **停止位**：标识数据帧的结束。

* **波特率**：表示每秒钟传输的比特数（bps）。常见的波特率有9600、115200等。==发送端和接收端必须使用相同的波特率==。

**缓冲区**：用于临时存储数据，作用如下：

1. 流量控制：防止数据溢出。当数据传输速度超过处理速度时，缓冲区可以暂时存储数据，避免丢失。

2. 数据平滑：提高传输效率。缓冲区可以将数据按批次处理，而不是逐位处理，提高传输和处理效率。

3. 异步操作：支持异步I/O。重叠I/O（Overlapped I/O）需要使用缓冲区来管理异步数据传输。



### 2 配置参数

```cpp
#include <windows.h>
#include <iostream>

int main() {
    // 打开串口
    HANDLE hSerial = CreateFile("COM1", GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
    if (hSerial == INVALID_HANDLE_VALUE) {
        std::cerr << "Failed to open COM port" << std::endl;
        return 1;
    }

    // 1 设置串口参数，帧结构DCB
    DCB dcbSerialParams = { 0 };
    dcbSerialParams.DCBlength = sizeof(dcbSerialParams);
    if (!GetCommState(hSerial, &dcbSerialParams)) {
        std::cerr << "Failed to get current serial parameters" << std::endl;
        CloseHandle(hSerial);
        return 1;
    }
    
    dcbSerialParams.BaudRate = CBR_9600;   // 波特率
    dcbSerialParams.ByteSize = 8;  		   // 数据位
    dcbSerialParams.StopBits = ONESTOPBIT; // 停止位
    dcbSerialParams.Parity = NOPARITY;     // 校验位
    
    if (!SetCommState(hSerial, &dcbSerialParams)) {
        std::cerr << "Failed to set serial parameters" << std::endl;
        CloseHandle(hSerial);
        return 1;
    }

    // 2 设置缓冲区大小
    if (!SetupComm(hSerial, 100 * 1024, 100 * 1024)) {
        std::cerr << "Failed to setup serial buffer" << std::endl;
        CloseHandle(hSerial);
        return 1;
    }
    return 0;
}

```

###  3 发送读取

* 通信本质：串口就是一个文件，打开串口就是打开一个指定的文件
* 外部设备向串口文件`WriteFile`写入，主机读取串口`ReadFile`文件
* 从而进行通信

```cpp
int main()
{
    // 写入数据
    const char *data = "Hello, Serial Port!";
    DWORD bytesWritten;
    if (!WriteFile(hSerial, data, strlen(data), &bytesWritten, nullptr)) {
        std::cerr << "Failed to write to serial port" << std::endl;
    } else {
        std::cout << "Written " << bytesWritten << " bytes to serial port" << std::endl;
    }

    // 读取数据
    char buffer[256];
    DWORD bytesRead;
    if (!ReadFile(hSerial, buffer, sizeof(buffer), &bytesRead, nullptr)) {
        std::cerr << "Failed to read from serial port" << std::endl;
    } else {
        std::cout << "Read " << bytesRead << " bytes from serial port: " << buffer << std::endl;
    }
	
    // 关闭串口
    CloseHandle(hSerial);
}
```

### 4 读写函数

`WriteFile` 和 `ReadFile` 是 Windows API 函数，用于在文件、串口设备、管道等上执行同步或异步的读写操作。这些函数提供了一种与操作系统低级别交互的方式，以便对各种设备或文件进行数据传输。

### WriteFile

#### 功能
`WriteFile` 函数用于将数据从缓冲区写入到文件或设备。

#### 函数原型
```cpp
BOOL WriteFile(
    HANDLE       hFile,
    LPCVOID      lpBuffer,
    DWORD        nNumberOfBytesToWrite,
    LPDWORD      lpNumberOfBytesWritten,
    LPOVERLAPPED lpOverlapped
);
```

#### 参数
- **hFile**: 要写入的文件或设备的句柄。此句柄必须已经打开，并且具有写权限。
- **lpBuffer**: 指向包含要写入数据的缓冲区的指针。
- **nNumberOfBytesToWrite**: 要写入的字节数。如果 `lpOverlapped` 为空，则在该操作完成之前，该函数将尝试写入所有字节。
- **lpNumberOfBytesWritten**: 指向接收实际写入字节数的变量的指针。如果 `lpOverlapped` 为空，则该参数不能为空。
- **lpOverlapped**: 指向 `OVERLAPPED` 结构的指针，该结构用于异步操作。如果该操作是同步的，则该参数可以为 `NULL`。

#### 返回值
- **TRUE**: 操作成功。
- **FALSE**: 操作失败。使用 `GetLastError` 获取详细的错误信息。

#### 用法
```cpp
// 同步写入示例
HANDLE hFile = CreateFile(...); // 打开文件
const char *data = "Hello, World!";
DWORD bytesWritten;
BOOL result = WriteFile(hFile, data, strlen(data), &bytesWritten, NULL);

if (result) {
    // 写入成功
} else {
    // 写入失败
    DWORD error = GetLastError();
}
```

### ReadFile

#### 功能
`ReadFile` 函数用于从文件或设备读取数据到缓冲区。

#### 函数原型
```cpp
BOOL ReadFile(
    HANDLE       hFile,
    LPVOID       lpBuffer,
    DWORD        nNumberOfBytesToRead,
    LPDWORD      lpNumberOfBytesRead,
    LPOVERLAPPED lpOverlapped
);
```

#### 参数
- **hFile**: 要读取的文件或设备的句柄。此句柄必须已经打开，并且具有读权限。
- **lpBuffer**: 指向接收读取数据的缓冲区的指针。
- **nNumberOfBytesToRead**: 要读取的字节数。
- **lpNumberOfBytesRead**: 指向接收实际读取字节数的变量的指针。如果 `lpOverlapped` 为空，则该参数不能为空。
- **lpOverlapped**: 指向 `OVERLAPPED` 结构的指针，该结构用于异步操作。如果该操作是同步的，则该参数可以为 `NULL`。

#### 返回值
- **TRUE**: 操作成功。
- **FALSE**: 操作失败。使用 `GetLastError` 获取详细的错误信息。

#### 用法
```cpp
// 同步读取示例
HANDLE hFile = CreateFile(...); // 打开文件
char buffer[128];
DWORD bytesRead;
BOOL result = ReadFile(hFile, buffer, sizeof(buffer), &bytesRead, NULL);

if (result) {
    // 读取成功
} else {
    // 读取失败
    DWORD error = GetLastError();
}
```

### 异步操作

`WriteFile` 和 `ReadFile` 也可以进行异步操作，通过提供一个 `OVERLAPPED` 结构来实现。

#### 示例

```cpp
// 异步写入示例
HANDLE hFile = CreateFile(..., FILE_FLAG_OVERLAPPED, ...);
const char *data = "Hello, World!";
DWORD bytesWritten;
OVERLAPPED ol = {0};

BOOL result = WriteFile(hFile, data, strlen(data), NULL, &ol);

if (!result) {
    DWORD error = GetLastError();
    if (error == ERROR_IO_PENDING) {
        // 异步操作正在进行中
        GetOverlappedResult(hFile, &ol, &bytesWritten, TRUE);
    } else {
        // 写入失败
    }
}
```

```cpp
// 异步读取示例
HANDLE hFile = CreateFile(..., FILE_FLAG_OVERLAPPED, ...);
char buffer[128];
DWORD bytesRead;
OVERLAPPED ol = {0};

BOOL result = ReadFile(hFile, buffer, sizeof(buffer), NULL, &ol);

if (!result) {
    DWORD error = GetLastError();
    if (error == ERROR_IO_PENDING) {
        // 异步操作正在进行中
        GetOverlappedResult(hFile, &ol, &bytesRead, TRUE);
    } else {
        // 读取失败
    }
}
```

### 总结

- **WriteFile** 和 **ReadFile** 是用于文件和设备的同步或异步读写操作的 Windows API 函数。
- 通过指定 `OVERLAPPED` 结构，可以实现异步操作，使得读写操作不会阻塞调用线程。
- 这两个函数对于处理串口通信、文件 I/O 等非常重要，特别是在需要高效处理 I/O 操作的应用程序中。

###  

## 5.3 物理连接

<img src="https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures/img/202405311525678.png" alt="image-20240531152507612" style="zoom:67%;" />

在计算机通信中，串口通信可以通过物理线缆连接两台计算机，也可以通过虚拟串口来模拟两台计算机之间的通信。

**物理线缆连接**

通常情况下，如果要在两台计算机之间进行串口通信，需要使用物理串口线缆将它们连接起来。这种连接方式可以是：

- 直接连接：通过一根串口线将两台计算机的串口相连。
- 通过转接设备连接：例如使用串口转USB转接器将串口连接到计算机的USB端口。
- 在物理串口通信中，通信的两端分别是主机（例如计算机）和外部设备（例如传感器、PLC、嵌入式设备等）。两端的串口通过串口线缆连接，实现数据传输。

**虚拟串口连接**

除了物理线缆连接外，还可以使用虚拟串口软件模拟两台计算机之间的串口通信。这种方法通过软件模拟出多个虚拟串口，并通过计算机内部的通信进行数据传输。这种连接方式常用于模拟测试、软件开发和调试等场景。

