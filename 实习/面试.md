**1 说一下你的项目吧**

公司主项目是铁路信号检测系统，我参与的部分是仿真工具的开发，用于模拟发送相关协议的信号给检测系统，帮助校验逻辑

我实习大概分为两个部分，一个熟悉掌握项目运用的协程框架，然后基于协程的实现多维调度线程池的开发

第二个部分，就是熟悉具体的协议文档，然后基于文档完成协议的封装到发送



**2 线程和协程的区别？？**

线程是轻量级的进程，是资源调度的最小单位，虽然已经大幅度提高了并发能力，但是线程的切换仍然有内核态切换的开销，当线程数量非常多的时候，有可能会适得其反

1. 协程是轻量级用户态的线程，切换不需要经过内核态，由开发者控制切换时机，没有时间和资源开销
2. 协程可以以同步变成的思维方式，来开发异步编程，降低了异步编程的难度
3. 简单的异步编程我们可以直接在协程中处理，复杂的异步我们可以通过协程调用线程池处理

**3 无栈协程是什么？**

协程不用维护自己的调用栈，所有的状态信息存储在堆中，切换协程只需要保存当前上下文，恢复下一个协程的上下文即可完成切换

有栈协程的切换需要维护自己的调用栈，支持复杂的调用，偏向于线程。无栈协程更加的轻量，适合快速的上下文切换。



**4 c++20怎么实现协程？**

我在项目中实现一个协程，主要分为三个部分

c++20提供三个关键字，co_await、co_return、co_yield

co_await作用于一个Awaitable对象，用于挂起当前协程。不阻塞当前线程的执行

co_return 提供协程返回的功能，可以返回空或者协程异步执行的结果

co_yield  提供在不结束协程的情况下，多次返回结果



构建AwaitAble对象

bool await_ready() :  返回true表示不用挂起，false需要挂起

void await_suspend()： 函数内部主要实现需要异步执行的操作,执行完毕后，通过句柄唤醒协程

await_resume()：返回执行的结果



协程的返回对象, 内置promise_type对象，调用到时，立即在堆上开辟空间

get_return_object()  initial_suspend()  return_value  reutrn_void  final_suspend()



**5 协程间通信怎么实现？**

协程实在线程上执行的，所以通信和进程通信一样

通过coNotify保证协程之间的同步互斥

通过链表保存协程的句柄，并分配定时器，wait（-1）永远阻塞，wait（10）定时器超时唤醒，notify()手动唤醒



**6 frameWork是什么？**

以协议为例，我们将每一种协议以及用到的底层库全部编译为一个动态库，放在可执行文件的同级目录下，当启动仿真工具时，会根据当前的配置，动态读取指定的dll加载到qt工具中，方便增删



**7 manger管理协议是什么**

插件框架根据优先级读取到dll后，manger会获取dll中的构建函数，创建出对应的界面，以及加载相关的配置数据到界面



**8你是如何设计任务节点接受任意类型的函数**

使用可变参模板 以及 c++17的特性  元组  和 apply函数

结构体 保存： 函数f指针、可变参数， work中使用apply执行函数，done唤醒协程， 可保存返回值



**9  线程池有什么需要改进的？**

目前的线程是并发和同步混合执行的，让线程池根据任务的类型自动选择相关的线程池执行

常见的任务有cpu密集型和io密集型，cpu密集型任务执行时间长、耗费性能高，适合同步，配备性能更合适的线程池

固定线程池的大小，内核+1

io密集需要等待外部资源，cpu利用少，适合并发处理，可动态的扩增线程池，长时间不用则销毁到固定大小

目前是由开发者手动采用不同的api进行任务提交

考虑只通过1api可以自动识别任务类型，方案有：提交的时候添加参数指定类型，或者是线程池根据函数的调用接口自己判断，io接口多或者计算接口多



**10 面试反问**

技术：

代码有开发文档吗？有没有单独的供消费者阅读的文档？

目前公司的c++相关开发人员有多少？工作年限平均是多少呢？

对一个应届生来说，公司期望学生的开发能力能到达什么水平呢？进公司后，最需要先掌握的技术是什么？

一般是怎么追踪bug的？日志？

公司的技术框架迭代频率快吗？



公司中的文化空白是什么？或者说公司目前正在积极鼓励员工做什么？

有没有申请调岗的制度，比如说在另一方面更有潜能？是否可以申请更换工作地点？

当管理层的预期和工程师的绩效之间有差距的时候如何处理

公司如何保证人才不流失？

