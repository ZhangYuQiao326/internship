2023 - 3 -13

腾讯客户端实习

![image-20240313153352129](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240313153352129.png)

# c++基础

**1 const作用**

面向过程： const修饰的常量，放在代码段，定义时必须初始化，且仅本文件可见

面向对象：const成员变量只能通过初始化列表进行初始化，const成员方法在调用const对象时不会修改

传参：const形参可以接收任意实参，且const对象只能调用const方法

**2 static关键字的作用**

面向过程角度

* 修饰==全局变量、函数==，修饰过后，全局变量和函数只能在当前文件可见，是因为在编译生成的符号表中，符号作用域从g（global）变为l（local）
* 修饰==局部变量==，初始化不为0的，放在data段，未初始化和初始化为0，放在bss段
* 局部变量本身不产生符号，通过ebp-偏移量访问，static后，产生local符号

面向对象角度

* 修饰成员变量，变为全局共享，类里面定义，类外初始化
* 修饰成员方法，不再产生this指针，可以通过作用域调用，且static方法只能调用static变量
* static成员方法不能背const 和 virtual修饰，const是因为不调用成员变量，也不会修改，virtual是因为static与类有关，与实例无关，没有多态可言

**3 volatile关键字的作用**

告诉编译器不要对该变量进行优化，因为该变量的值可能会在编译器优化的作用下发生变化，例如==多线程环境==中，变量可能会被其他线程修改。

在多线程编程中，`volatile`关键字用于确保线程之间对共享变量的可见性。当一个变量被声明为`volatile`时，每次对该变量的读取都会直接从内存中读取，而不是从缓存中读取，同时每次对该变量的写入也会直接写入到内存中，而不是先写入到缓存。这样可以确保当一个线程修改了该变量的值后，其他线程能够立即看到这个修改，而不会因为缓存而导致数据不一致的情况发生。

需要注意的是，`volatile`只能保证可见性，不能保证原子性。如果需要确保多线程环境下对变量的读取和写入是原子操作的，还需要使用其他机制，比如使用`mutex`（互斥锁）或`atomic`类型等。

 

**4 mutable关键字**

mutable作用于==类的成员变量==，即便在const成员函数中，也可以对其进行修改

```cpp
class MyClass {
public:
    mutable int x;
    MyClass(int val) : x(val) {}
    
    void modifyX() const {
        x++; // 即使在const成员函数中，x也可以被修改
    }
};
```



注意和`const_cast`进行区分，这个作用于const修饰的变量和volatile属性修饰的变量



**5 explict关键字**

作用域==类的构造函数==，修饰的构造函数不能再发生隐式类型转换，必须通过显示构造



**3 c++如何调用c语言？**

c 和 c++在编译过程中的==函数名修饰规则==不同，c是根据==函数名==表示，c++会根据==函数名==和==参数==命名，因此编译c语言需要在`extern "C"{}`之中

同样的原因，c++导致相同函数名，参数不同的函数在==符号表==内的名字不同，这也是==函数重载==的原理



**4 c 和 c++的区别**

1面向对象，使用设计模式      2 引用    3函数重载    4 new和delete   5  异常处理   6 模板  7 STL



**5 const int* p  和 int* cosnt p的区别**

常量指针：const int* p = &a; 即指针的解引用是常量的，即*p不变，但是p = b;

指针常量 int * constp = &a;  指针本身是不变的，解引用可以改变*p = 20;



**6 指针和引用区别**

指针是变量，开辟内存，存指向变量的地址，引用是别名，与变量共享地址

指针可以为空，且可以修改，引用必须初始化，且只能定义一次

引用的本质是指针常量（int* const），是c++的语法糖

指针和引用都可以作为参数传递，减少对变量的拷贝，但是传指针本质上也是值传递，对指针的内容，也就是地址做了拷贝，若在函数内部修改了指针的内容，不会影响函数外部的指针，但是函数内部修改指针指向的位置，即变量，就会修改变量

传引用不存在拷贝，传的就是变量本身



**7 什么时候使用指针传参和引用传参？**

当需要==返回函数内部的通过new出来的局部变量==时候，通过传入指针，保存局部变量的值，但是后续注意释放，内存泄漏

但是也是因为传入指针需要额外开辟空间，对于==对栈内存敏感==的函数（递归）优先使用引用

==类对象的传递==也是使用引用

|              | 只使用传递过来的值，而不对值进行修改 | 需要修改传递过来的值 |
| ------------ | ------------------------------------ | -------------------- |
| 内置数据类型 | 按值传递（小型结构）                 | 指针传递             |
| 数组         | 指针传递                             | 指针传递             |
| 结构         | 指针或引用（较大的结构）             | 指针或引用           |
| 类、对象     | 引用传递                             | 引用传递             |

**8 如何判断大小端存储？**

* 电脑： 小端法

高位存高地址、低位存低地址

* 网络 大端

<img src="C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240314170616566.png" alt="image-20240314170616566" style="zoom: 67%;" />



使用强制类型转换解决

```cpp
#include <iostream>
using namespace std;
int main()
{
    int a = 0x1234;
    //由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分
    char c = (char)(a);
    if (c == 0x12)
        cout << "big endian" << endl;
    else if(c == 0x34)
        cout << "little endian" << endl;
}

```



**9 函数调用栈过程，参数or返回值先入栈？**

1. 保存当前环境的==系统状态==，便于恢复

1. 首先，调用函数时，将调用者==函数的返回地址==压入栈中，以便在函数调用结束后返回到调用者函数的适当位置。
2. 接下来，将调用者函数的==参数==依次压入栈中，通常是从右往左的顺序。
3. 然后，在调用的函数内部执行时，会在栈上分配空间用于==局部变量==、函数内部的==临时变量==以及其他需要的数据。
4. 函数执行结束后，==返回值==会被放入调用者函数期望的位置（通常是寄存器或者内存），然后函数返回到调用者函数处，将栈上的数据恢复到调用前的状态，包括返回地址和参数等。

因此，在函数调用过程中，参数变量会先于返回值入栈。这是因为参数需要在函数内部使用，而返回值通常是在函数执行结束后才需要。



**10 static_cast为什么安全？**

1. 在不引入额外开销的情况下进行类型转换
2. 显示的注明类型转换，避免隐式类型转换造成的问题
3. 保持了const的属性，转换前后的const属性不变



## 类

**1 c++的this指针是干什么用的？**

this实际上是成员函数的一个形参，在调用成员函数时候，会将对象的地址作为实参传递给this，

this是局部形参，只能用在成员函数的内部，只有调用成员函数时才给this传值



**2 什么情况下发生拷贝构造？**

* 用一个实例化对象去初始化另一个对象
* 通过值传递方式传入对象
* ==vs==下值传递方式返回一个对象， g++下不会调用拷贝构造

**1 继承的赋值兼容规则**？

派生类对象可以赋值给基类对象、基类对象指针、基类对象引用，这个过程中会发生切片

反过来，若是基类对象想赋值给派生类对象指针，则需要通过dynamic_cast进行判断，若基类指针是指向派生类的对象，则可以赋值成功，否则失败



**2 派生类的构造函数和析构函数是怎么样的？**

* 派生类对象必须调用基类的==构造方法==初始化基类的成员变量，若基类没有默认的构造函数，则必须在派生类的初始化列表中显示调用
* 派生类对象必须调用基类的==拷贝构造==和==运算符重载==给基类的成员变量赋值
* 派生类的==析构函数==会在执行完毕后自动调用基类的析构函数

<img src="C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240313164545853.png" alt="image-20240313164545853" style="zoom:33%;" />

* 当派生类和基类由同名的成员方法时，派生类会隐藏掉基类的方法和变量，可以通过基类的作用域调用



**3 继承和组合区别是什么？**

两种都是类的复用技术

继承允许根据基类的实现来定义派生类，基类的内部对派生类可见，耦合度很高，两个类有关系则优先使用，实现多态也要使用

==组合==是将基类封装在另一个类的内部，基类的内部对其不可见，耦合度很低，代码维护性好



**4 继承的好处是什么？**

* 实现了代码复用
* 可以通过继承，在基类的内部给所有派生类保留同一的纯虚函数接口，派生类进行重写，可以实现多态，即通过基类指针访问不同派生类对象的同名覆盖方法





## 内存管理

**1 new和delete，什么时候用new[]申请的内存，可以用delete释放**？

new的作用是 申请开辟内存空间 +申请失败抛异常 +  调用对象的构造函数

operator new  是 malloc + 申请内存失败抛异常

 malloc： 申请失败return 0 

delete： 释放内存空间 + 调用对象的析构函数

operatpr delete 和 free 区别不大

== 对于自定义类型，如果提供了析构函数，当使用new[]申请空间时，除了申请对象外，额外申请4个字节记录对象的申请个数，必须调用delelte[]释放==

其余情况下，使用new[]申请，可以用delete ptr释放

**2 虚拟地址空间**

<img src="C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240313161217327.png" alt="image-20240313161217327" style="zoom:67%;" />





.bss： 未初始化、初始化为0的==全局变量==，未初始化、初始化为0的==静态变量==

* 不在可执行未见中，由系统初始化，初始化时，部分bss段清0

.data ：初始化不为0的==全局变量==和==静态变量==

.text : 存放程序执行代码、只读==常量==、==字符串常量==、==类的成员函数==，==静态成员变量、静态成员函数==

* data text在可执行文件中，系统从可执行文件中加载

```cpp
int bss_1;// 未初始化的全局变量，bss段
int bss_2 = 0;// 初始化为0的全局变量，bss段
int data_1 = 1;// 初始化非0的全局变量，data段
int main() {
    static int bss_3;// 未初始化的静态局部变量，bss段
    static int bss_4 = 0;// 初始化为0静态局部变量，bss段
    static int data_2 = 1;// 初始化非0静态局部变量，data段
}
```



**3 如何防止内存泄漏**

内存泄漏不是指物理内存上的泄漏，而是指不适用的内存没有释放，导致对其的控制

常见的两种

* 堆内存泄漏：指用户通过new malloc operator new等申请的内存资源使用完毕后，没有用delelte free释放，，导致无法使用
* 在多态中，基类析构函数没有声明为虚函数，导致派生类调用析构时没有调用到基类析构，导致基类成员变量没有被释放
* 系统资源泄漏：套接字、文件描述符等使用韩币后没有释放

对长期运行的程序危害比较大，比如操作系统、后台服务等

linux下的内存检测工具：valgrind

windows下常见的工具有 CRT



**4 什么时候出现访问越界？**

越界即系统给你分配了固定的内存，你访问到了外部的内存即越界

* 访问数组、vector会越界
* 字符串处理没有带0，会越界
* 在dynamic_cast中，派生类指针指向基类对象失败，解引用会越界



**开辟内存方式**

1. `malloc`（Memory Allocation）：
   - 函数签名：`void* malloc(size_t size);`
   - 作用：用于分配指定大小的堆内存，返回一个指向分配内存的指针。如果分配成功，返回一个合法的指针；如果分配失败，返回`NULL`。

2. `calloc`（Contiguous Allocation）：
   - 函数签名：`void* calloc(size_t num_elements, size_t element_size);`
   - 作用：用于分配指定数量和大小的连续块内存，返回一个指向分配内存的指针。所有分配的内存都被初始化为零。如果分配成功，返回一个合法的指针；如果分配失败，返回`NULL`。

3. `realloc`（Reallocate Memory）：
   - 函数签名：`void* realloc(void* ptr, size_t new_size);`
   - 作用：用于重新调整先前分配的内存块的大小。通常用于扩展或缩小内存块。它接受一个先前分配的内存块指针和新的大小作为参数，返回一个指向重新分配内存的指针。如果分配失败，返回`NULL`。如果`ptr`为`NULL`，则`realloc`的行为等同于`malloc`。

## STL

**1 讲一下空间配置器**

空间配置器主要是给容器使用的

* 一是把内存开辟和对象构造分开，把内存释放和对象析构分开，因为有一些场景下是需要先开辟空间，在后续执行过程中在创建对象，在析构对象后，也不需要释放内存空间
* 二是解决==频繁向系统申请小块内存==的问题，容易造成资源泄露
* 原理：配置器有两级构成，以128字节为界限将内存块分为大内存和小内存，大内存块的申请释放由一级配置器进行管理，对mallo和free与申请失败抛异常进行封装，和operator new差不多
* 二级配置器用来管理小内存，底层是一个哈希桶，内存申请的大小是从8字节到128字节
* 为什么是8个字节，因为下方挂的是内存块，为表示64位下的地址空间，采用8字节



**2 vector和list的区别**

vector支持随机访问，优先级队列就是基于vector构建的适配器

list支持高效的增删改查

## 数据结构

![image-20240313180924748](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240313180924748.png)



## c++11

**1 智能指针**



**2 初始化列表**

功能：可以通过初始化列表指定成员变量的初始化方式，在类中，成员变量的初始化顺序与其声明的顺序一致，与初始化列表内的顺序无关

底层：`myvector(std::initializer_list<T> il)`,std指定初始化列表容器，用来接收值

`std::initializer_list ilt = { 10, 20, 30 }`





# 网络

## HTTP

## TCP

* 运行在计算机上的进程通过端口号来区分，16bit标识，0~ 65535

  | 类型 | UDP                              | TCP                    |
  | ---- | -------------------------------- | ---------------------- |
  |      | 支持一对一，一对多               | 一对一                 |
  |      | 面向报文                         | 面向字节流             |
  |      | 无连接                           | 面向链接               |
  |      | 不安全                           | 安全                   |
  |      | 向上层提供无连接、不可靠传输服务 | 面向连接的可靠传输服务 |
  |      | 视频、会议等实时                 | 文件传输               |

  

![image-20240314183205222](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240314183205222.png)

![image-20240328154625330](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240328154625330.png)

![image-20240314192809279](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240314192809279.png)

### 1 重传机制

#### 1.1 超时重传

利用定时器,当发送方发送数据超过RTO(超时重传时间),则再次发送数据

RTO设置略大于RTT(往返时延)

1. RTO小,则会导致没有丢包就重发数据,导致阻塞.会发送多余的重复数据,浪费资源
2. RTO大,导致网络存在多余的空闲时间

问题:超时周期过长

#### 1.2 快速重传

当收到三次联系的ACK应答帧,触发重传机制

解决:发送方丢包的问题

缺点: 发送方丢失多个包,是重传一个,还是重传所有?

1个: 当丢了多个包时,三个ack触发一次包重传,在需要3个ack才能触发下一个包重传,太耗时

所有: 全部重传,则导致发送重复包

#### 1.3 SACK

选择性确认(select ack)

在tcp报文的 = 选项= 字段添加 SACK字段,记录接收方已经接收到的包

若ACK确认序列号 < SACK的值,说明有包丢失

触发三次ack重传,发送丢失包

#### 1.4 D-SACK

告诉发送方哪些数据发送重复

同样在SACK字段, 记录已经接收到的包

解决: 

1. 接收方的ack确认丢失, 发送方超时后,发送数据帧, 接收方返回sack记录数据一重复,表面是上个ack丢失
2. 网络阻塞,导致发送方数据阻塞. 接收方连续三次ack发起重传, 接收方接收数据. 当上一个数据网络恢复后被接收方接收,则sack记录数据重复,说明是网络阻塞

### 2 滑动窗口

传统tcp通信: 1次发送数据, 收到ack后, 再次发送数据, 收到ack

滑动窗口: 发送方可以发送的,没有收到ack确认的发送数据最大个数

由接收方决定窗口大小, tcp的窗口大小字段,表示接收方能处理的最大数据量

接收方窗口大小 和 发送方窗口大小 约等于

### 3 流量控制

浏览控制基于滑动窗口

接收方通过ack通知发送方动态调整窗口大小

若窗口变大,则提高发送方的发送效率

若窗口变小,则降低发送效率

### 4 拥塞控制

# 操作系统

## 1 进程、线程、协程

### 1.1 PCB、进程状态、调度

操作系统对进程进行管理，实际上是将进程控制块PCB放入链表中，进行增删改查

```cpp
struct task_struct{
    // pid
    // PRI NI 优先级
    // task_state_array  进程状态
    // mm_struct  进程地址空间
}
```

进程状态的本质：进程的pcb放入不同的队列

* 执行态：pcb放入cpu管理的任务执行队列中，放入即为执行态
* 阻塞态：进程需要外设资源，没有即阻塞，将pcb从执行队列放入外设管理的wait等待队列
* 挂起态：进程在阻塞态的时候，仍浪费内存，os将其置换到磁盘之中

linux下通过结构体进行管理

![image-20240320144553504](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240320144553504.png)



**2 多级反馈队列调度算法**

--用于处理cpu管理的任务执行队列中的待执行进程的先后顺序调度

1. 先来先服务，利于长作业进程，短作业可能会饿死
2. 短作业优先，不利于长作业
3. 最短剩余时间悠闲，比较进程还需要多少时间片，最短的执行
4. 优先级调度，linux中的优先级通过PCB中的PRI(priority) 和 NI(nice) 控制，用户可以设置NI的值来改变优先级，范围【-20，19】
5. 时间片轮转，过长不利于进程的实时性，过短造成大量上下文切换，浪费性能
6. 多级反馈队列，优先级与时间片的结合，进程没有执行完则放入下一个队列，每一个队列有优先级，第一层最高，每个队列内按时间片轮转控制
   * 进程在进入待调度的队列等待时，首先进入[优先级](https://baike.baidu.com/item/优先级/5643121?fromModule=lemma_inlink)最高的Q1等待。
   * 首先调度优先级高的队列中的进程。若高优先级中队列中已没有调度的进程，则调度次[优先级队列](https://baike.baidu.com/item/优先级队列/6737671?fromModule=lemma_inlink)中的进程。例如：Q1,Q2,Q3三个队列，[当且仅当](https://baike.baidu.com/item/当且仅当/7689242?fromModule=lemma_inlink)在Q1中没有进程等待时才去调度Q2，同理，只有Q1,Q2都为[空时](https://baike.baidu.com/item/空时/389840?fromModule=lemma_inlink)才会去调度Q3。
   * 对于同一个队列中的各个进程，按照FCFS分配时间片调度。比如Q1队列的[时间片](https://baike.baidu.com/item/时间片/6525414?fromModule=lemma_inlink)为N，那么Q1中的作业在经历了N个时间片后若还没有完成，则进入Q2队列等待，若Q2的时间片用完后作业还不能完成，一直进入下一级队列末尾，直至完成。
   * 在最后一个队列QN中的各个进程，按照[时间片轮转](https://baike.baidu.com/item/时间片轮转/7256857?fromModule=lemma_inlink)分配时间片调度。
   * 在低[优先级](https://baike.baidu.com/item/优先级/5643121?fromModule=lemma_inlink)的队列中的进程在[运行时](https://baike.baidu.com/item/运行时/3335184?fromModule=lemma_inlink)，又有新到达的作业，此时须立即把正在运行的进程放回当前队列的[队尾](https://baike.baidu.com/item/队尾/53401782?fromModule=lemma_inlink)，然后把[处理机](https://baike.baidu.com/item/处理机/128842?fromModule=lemma_inlink)分给高优先级进程。换而言之，任何时刻，只有当第1~i-1队列全部为空时，才会去执行第i队列的进程（抢占式）。特别说明，当再度运行到当前队列的该进程时，仅分配上次还未完成的时间片，不再分配该队列对应的完整时间片

<img src="https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240320165427807.png" alt="image-20240320165427807" style="zoom: 50%;" />

### 2 父子进程

在 Linux 操作系统中，当父进程通过 `fork()` 系统调用创建子进程时，子进程会继承父进程的虚拟地址空间，包括 `mm_struct` 和页表。然而，尽管它们在初始时看起来相同，但子进程的执行会有所不同，原因如下：

1. **写时复制（Copy-On-Write, COW）**：
   - 当 `fork()` 被调用时，子进程会共享父进程的内存页，直到有一个进程尝试写入这些页。这种机制被称为写时复制。
   - 一旦任何进程（父进程或子进程）尝试写入共享的内存页，内核会创建该页的副本，并将写入操作重定向到新的副本。这意味着，尽管父子进程最初共享相同的页表，实际的物理内存页在写入后会有所不同。
   - 这种机制确保了父进程和子进程的内存彼此独立，不会互相影响。
2. **进程控制块（PCB）和 CPU 寄存器**：
   - 每个进程都有自己的进程控制块（PCB），其中包含进程的状态信息、寄存器内容、程序计数器等。
   - 在 `fork()` 调用后，子进程会从父进程的 PCB 复制一份，并且在内核返回到用户态之前，内核会将子进程的程序计数器设置为 `fork()` 调用的返回地址。
   - 因此，父进程和子进程在用户态代码中的执行路径是独立的，尽管它们最初共享相同的内存内容和地址空间。
3. **文件描述符**：
   - 子进程会继承父进程的文件描述符，这意味着子进程可以访问父进程打开的文件。但它们的文件描述符表也是独立的修改时不会互相影响。

### 3 进程通信

| 通信方式   | 详细                                                         |
| ---------- | ------------------------------------------------------------ |
| 管道       | 分为匿名管道、命名管道；不适合频繁发送数据、开销大           |
| 消息队列   | 本质是保存在内核中的消息链表，通信不及时，不适合发送大数据   |
| 共享内存   | 不同进程通过虚拟地址映射同一块物理地址，多进程下的同步问题   |
| 信号       | 处理异常情况下的进程 kill -9，==唯一的异步通信机制==，在⼀个进程中通知另⼀个进程发⽣了某种事件从⽽实现进程 通信 |
| 同步机制： |                                                              |
| 信号量     | 实现（共享内存）进程的互斥和同步PV操作                       |
| socket     | 跨网络进程通信                                               |
| 串口通信   | 位传输、点对点、跨设备（主机和外设间的通信）                 |

* 管道

  1. 分为匿名管道、有名管道。匿名管道用完即销毁，有名管道提前创建，进程只要使用文件，就可以通信

  2. 基于文件的流式通信，以字节流在管道内传输，通过操作系统进行内核传输

  3. 适用于两个进程之间通信，匿名：常用于父子进程、相关性进程，有名：不相关进程

  4. 优势：流式传输，不需要显示的同步机制

     劣势：传输通过操作系统内核，效率低。管道满会被阻塞。

* 共享内存

  1. 多个进程访问1块共享内存

  2. 基于内存的通信，直接在空间读写，不需要经过内核。

  3. 优点：高效大规模数据传输，直接访问内存，效率高

     缺点：多个进程访问，需要显示同步机制（信号量、互斥锁），实现复杂

![image-20240722114251698](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures/img/202407221142752.png)

### 4 线程互斥

| 方式     | 原理                                                     |
| -------- | -------------------------------------------------------- |
| 互斥锁   | mutex、lock_guard<mutex>、shared_lock<mutex>             |
| 条件变量 | condition_varible cond_   、wait、 wait_for 、notify_one |
| 信号量   |                                                          |



### 3 多线程

1. **进程与线程的区别**

* 一个进程通过fork创建子进程时，会对该进程的资源进行拷贝，包括虚拟地址和页表等，因此父子进程的虚拟地址相同。当子进程对空间进行写入时，基于写时复制原则，会重新映射物理内存到页表，实现不同进程的隔离

* 一个进程通过vfork或clone创建子进程的时候，会直接共享父进程的资源和虚拟地址空间，资源计数加一，因此，父子进程共享部分资源和虚拟地址、页表，此时子进程被称作线程

* 进程、线程都拥有不同的状态

* 进程是资源分配单位，线程是cpu调度单位

* 线程的优势体现在：并发现高、时间开销、空间开销小

* 具体体现在：创建、销毁、调度。进程创建和销毁需要管理pcb资源等，线程共享部分资源和虚拟地址，只用管理寄存器，线程栈等私有资源，开销较小

  进程的切换需要保存cpu寄存器、程序计数器到PCB中，在读取下一个进程的pcb、涉及到切换页表等时间消耗高的操作。

  同一个进程内部的线程只需要管理私有的寄存器和栈等。开销小

* 线程的缺点：c++中的一个线程崩溃，导致所有线程（整个进程）崩溃。java则不会；

* 原因：c++中非法访问内存，os发送信号让进程奔溃。java中，拦截了os发送的信号，执行自定义信号，防止崩溃

1. **多线程的好处，只有单核多线程有意义吗？**

* 充分利用cpu的性能、减少cpu的空闲时间，提高并发量
* 加快用户的相应时间
* 不同的任务交付给不同的线程，实现代码模块化、优化简单化
* 单核多线程是通过给不同的进程分发时间片，使其宏观上是并发的



2. **线程切换栈会保留哪些？**

 进程是操作系统中资源分配和调度的基本单位，它拥有独立的地址空间和一组资源，所以进程切换时候需要保存的信息比较多

1. 将cpu寄存器和pc程序计数器保存在pcb中 （pc程序计数器、sp栈指针、状态寄存器、通用寄存器）

* 将pcb移动到切换状态的列表中
* 读取下一个进程的pcb内容，涉及到页表切换，耗时较大

线程是进程的执行单位，同一进程下的线程共享进程的地址空间和资源，但是每个线程有自己的执行栈和局部变量

* 首先是和进程一样，保存cpu的寄存器状态：pc、sp 通用寄存器、状态寄存器
* 线程id、线程 状态等
* 保存线程独自的栈指针，用来保存局部变量
* 如果进程给线程提供了空间来保存信息，这些空间也需要保存下来

---------



3. **线程数为什么要预先定义？**

* 不同的应用场景可能需要的线程数目不同，比如说cpu密集型任务需要的线程数较少，io型线程需要的线程数较多
* 线程的数目并不是越多越好，线程会占用一定的系统资源，比如说内存和cpu时间片，所以具体的线程数目需要在项目执行前就考虑好
* 如果在项目执行的过程中频繁的创建和销毁线程，会浪费大量的成本，极大影响效率，因此我们都是提前规划好线程的数目并且采用线程池，极大提高程序的性能。

4. 进程切换为什么比线程切换满？
   * 自身上下文切换
   * 进程切换设计虚拟内存的切换

### 3 进程死锁

1. **死锁的四个必要条件？**

​	① 互斥条件：1个资源每次只能被一个进程执行

​	② 请求与保持：一个进程因为等待资源而阻塞的时候，并不会释放已有的资源

​	③ 不可剥夺条件：一个进程没有执行完毕的时候，不能强行剥夺条件

​	④ 循环等待： 若干进程形成了首尾相连的等待资源关系

死锁原因： 资源缺乏、进程顺序安排不合理等

2. **如何避免以及解决项目的死锁？**

   * 预防死锁： ①预先分配资源： 若进程有一个资源不满足，则不分配任何资源

     ​					② 有序分配资源：进程按照指定顺序获取资源

     A进程获取资源1，2，B进程也获取1，2

   * 避免死锁： 银行家算法

     如果存在一种进程执行顺序，按照此顺序可以保证所有进程都获得最大的资源需求，则认为系统是安全的

   * 死锁检测和恢复： 定时检测、进程执行缓慢检测、进程循环等待时检测

     ​					恢复：①抢占资源：从其他进程中抢占资源接触死锁

     ​								② 杀死进程接触死锁

     ​								③进程回退到某个某个接触死锁的节点
   
   * 具体策略根据具体的业务选择，数据库系统经常采用死锁检测和进程回退。
   
   * 如何检测：linux下通过pstack命令查看线程栈 + gdb，阻塞状态的则考虑是否死锁

---------

5. **操作系统如何接收鼠标的点击事件并转发？**

   os不直接与鼠标交互，鼠标点击后，鼠标驱动向操作系统发送信号，包括点击信息（左右键、位置信息等），操作系统将这个输入信号封装成消息发送给应用程序，应用程序内部循环检测os发送的消息，检测到消息后，查看位置信息，寻找对应的空间，调用其函数

### 4 锁类型

**基本锁**

| 类型   | 介绍                                                         |
| ------ | ------------------------------------------------------------ |
| 互斥锁 | 独占锁，加锁失败，进入阻塞态，加锁成功，进入就绪态，发生两次==内核上下文切换== |
| 自旋锁 | 加锁失败，进入==忙等待==，不需要进入内核态上下文切换         |

* 当可以判断 **加锁后进程的执行时间**小于 上下文切换时间，选择自旋锁，否则互斥锁

**高级锁**

| 类型   | 介绍                                                         |
| ------ | ------------------------------------------------------------ |
| 读写锁 | 读时共享，写时互斥                                           |
| 乐观锁 | 无锁机制，假设资源不会冲突，进行操作，之后在判断是否冲突，冲突后手动修改后提交（git） |
| 悲观锁 | 假设所有资源都会冲突，访问就要加锁（互斥锁、自旋锁、读写锁） |

### 5 孤儿进程、僵尸进程

unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到。

这种机制就是: 在每个进程退出的时候**,内核释放该进程所有的资源**,包括打开的文件,占用的内存等。 但是仍然为其**保留一定的信息**(包括进程号the process ID,退出状态the termination status of the process,运行时间the amount of CPU time taken by the process等)。直到父进程通**过wait / waitpid来取时才释放**。 但这样就导致了问题

**如果进程不调用wait / waitpid的话，** **那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免**

**孤儿进程**（没有危害）：

一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

**僵尸进程**（严重危害）：

一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。

**守护进程**

独立于控制终端的孤儿进程，循环执行某任务，或者等待处理某个操作

**如何创建守护进程？**

1. 通过父进程创建子进程后，关闭父进程，子进程为孤儿进程，形式上脱离终端控制
2. 子进程中创建新会话，一个会话控制一个终端，真正独立于其他终端控制
3. （非必须）改变当前目录为根目录，防止占用文件系统资源
4. （非必须）关闭文件描述符，继承的打开文件不会用，占用资源
5. 执行守护进程的核心操作

**如何解决僵尸进程？**

（1）最简单的⽅法: ⽗进程通过 wait() 和 waitpid() 等函数等待⼦进程结束，但是，这会导致⽗进程挂起; 

（2）如果⽗进程要处理的事情很多，不能够挂起，通过 signal() 函数⼈为处理信号 SIGCHLD: 只要有⼦进程退出⾃动调⽤指定好的回调函数，因为⼦进程结束后， ⽗进程会收到该信号 SIGCHLD ，可以在其回 调函数⾥调⽤ wait() 或 waitpid() 回收;

 （3）如果⽗进程不关⼼⼦进程什么时候结束，那么可以⽤signal（SIGCHLD, SIG_IGN）通知内核: ⾃⼰对⼦进程的结束不感兴趣，⽗进程忽略此信号，那么⼦进程结束后，内核会回收，并不再给⽗进程发送信号; 

## 2 虚拟地址、物理地址

### 1 虚拟内存

** 进程地址空间**

进程地址空间是进程PCB中的一个变量

通过mm_struct结构体进行管理

【为什么需要进程地址空间？】

1. 若进程直接访问物理内存，可能会发生越界访问，不安全
2. 地址空间的存在，可以更方便的进行进程与进程之间的数据代码解耦，保证进程之间的独立性
3. 编译器也会按照进程地址空间的规则对代码进行编译
4. cpu读取的指令的地址都是虚拟地址

![image-20240320173630091](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240320173630091.png)



**作用**

在多进程环境下，使不同的内存地址不受影响，分配虚拟地址空间

物理内存只有一个，可能造成内存紧张，采用 **内存交换** 技术，将不常用的内存数据暂存在磁盘上

虚拟地址与物理地址的映射有两种 **分段**和 **分页**

|          | 分段                                | 分页                                   |
| -------- | ----------------------------------- | -------------------------------------- |
| 划分     | 基于逻辑，分为堆栈、bss data text段 | 虚拟地址和物理地址分为故固定大小页 4kb |
| 映射     | 基于段表（段起始物理地址+偏移量）   | 基于页表（虚拟地址 - 物理地址）        |
| 内存碎片 | 段大小不一致、外部碎片              | 内部碎片                               |
| 内存交换 | 段大小不一致，换入换出效率不高      | 交换部分页，效率高                     |
| 缓存技术 | \                                   | 局部性原理，TLB页表缓存，加快地址转换  |

**总结：虚拟内存的优势有哪些？**

1. 首先就是解决了多进程环境下的**进程地址冲突**问题，确保进程的独立安全
2. 操作系统可以通过页表对页设置 **属性权限**，比如读写权限，确保内存访问安全
3. 进程使用的虚拟地址远超物理地址，**基于局部性原理**，将不常用的内存数据换出磁盘上（磁盘swap上）

### 2 malloc

**2.1 两种内存分配方式**

* 当malloc空间小于128kb，从堆上申请，free 释放堆内存的时候，**并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用**；
* 当malloc空间大于128kb，从文件映射区申请，free 释放文件映射区内存的时候，**会把内存归还给操作系统，内存得到真正的释放**。

1. 通过brk()系统调用，从堆分配内存，brk指针向上移动

   <img src="https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240414170417942.png" alt="image-20240414170417942" style="zoom:50%;" />

   2. 通过mmap()系统调用，从文件映射区分配空间

      <img src="https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240414170533844.png" alt="image-20240414170533844" style="zoom:50%;" />

**2.2 为什么需要两种分配方式？**

完全使用mmap：从文件映射区分配内存，free完全释放内存， **在第一次访问虚拟地址时候发生缺页中断**，涉及到频繁的系统调用，需要进程在**用户态和内核态转换**，cpu开销大

结合使用brk，堆可以预先申请姣大的空间，内存申请和释放都在malloc的内存池中申请，**减少系统调用和缺页中断次数**



完全使用brk：malloc申请较大空间，后内存池变大，后续的小申请，会将内存池分割，导致碎片

因此，malloc申请过程中，大内存使用mmp，用完即释放，小内存使用brk，从内存池获取，减少系统调用



**2.3 free()传入地址，怎么知道释放多大的空间？**、

malloc申请地址的时候，会多申请16字节，用于存放申请的内存大小

free释放时候，向前便宜16字节，查询释放内存的大小

<img src="https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures/img/202407221040090.png" alt="image-20240414173022765" style="zoom:50%;" />

**2.4 malloc（1）申请多少字节？**

系统中内存的申请释放以页为单位，申请一个字节时，根据编译器或者系统，给堆上申请一个页表大小，释放内存后，将申请的所有内存还给malloc内存池



**2.5 在4GB的物理内存上，申请8GB的内存会发生什么？**

- 在 32 位操作系统，因为进程理论上最大能申请 3 GB 大小的虚拟内存，所以直接申请 8G 内存，会申请失败。

- 在 64位 位操作系统，因为进程理论上最大能申请 128 TB 大小的虚拟内存，即使物理内存只有 4GB，申请 8G 内存也是没问题，因为申请的内存是虚拟内存。如果这块虚拟内存被访问了，要看系统有没有 Swap 分区：
  - 如果没有 Swap 分区，因为物理空间不够，进程会被操作系统杀掉，原因是 OOM（内存溢出）；
  
    
  
  - 如果有 Swap 分区，即使物理内存只有 4GB，程序也能正常使用 8GB 的内存，进程可以正常运行；

### 3 改进lru算法

传统的 LRU 算法法无法避免下面这两个问题：

- 预读失效导致缓存命中率下降；
- 缓存污染导致缓存命中率下降；

为了避免「预读失效」造成的影响，Linux 和 MySQL 对传统的 LRU 链表做了改进：

- Linux 操作系统实现两个了 LRU 链表：**活跃 LRU 链表（active list）和非活跃 LRU 链表（inactive list）**。
- MySQL Innodb 存储引擎是在一个 LRU 链表上划分来 2 个区域：**young 区域 和 old 区域**。

但是如果还是使用「只要数据被访问一次，就将数据加入到活跃 LRU 链表头部（或者 young 区域）」这种方式的话，那么**还存在缓存污染的问题**。

为了避免「缓存污染」造成的影响，Linux 操作系统和 MySQL Innodb 存储引擎分别提高了升级为热点数据的门槛：

- Linux 操作系统：在内存页被访问**第二次**的时候，才将页从 inactive list 升级到 active list 里。

- MySQL Innodb：在内存页被访问

  第二次

  的时候，并不会马上将该页从 old 区域升级到 young 区域，因为还要进行

  停留在 old 区域的时间判断

  ：

  - 如果第二次的访问时间与第一次访问的时间**在 1 秒内**（默认值），那么该页就**不会**被从 old 区域升级到 young 区域；
  - 如果第二次的访问时间与第一次访问的时间**超过 1 秒**，那么该页就**会**从 old 区域升级到 young 区域；

通过提高了进入 active list （或者 young 区域）的门槛后，就很好了避免缓存污染带来的影响。

# 面试

2024-4-7 qq浏览器客户端1面

1. tcp 和 udp区别

2. tcp如何保证其可靠性，比如说传输的包有序、是否丢失 （答了三握四挥，含有seq和ack，分片传输，丢失补发，拥塞控制、流量控制。。。知道的都说了）

3. tcp片丢失如何补发的？（自己挖坑自己跳，不会。。。）

4. 说一下拥塞控制、流量控制 （又挖坑了。。。还好提前复习了）

5. 如何保证http连接过程中断开了，重连后还能恢复到之前的位置

   比如：下载文件，网络断开，恢复后仍能继续下载而不是重新下载

   （瞎答了tcp连接时，客户端断开，服务器不发消息则不知道断开，把面试官整笑了）

   提示： http头中有字段来记录位置

6. 说一下虚拟内存和物理内存 （只说了进程地址空间。。。）

7. 虚拟内存的好处是什么？（扩充内存、进程安全、还不够。。。。。）

8. 进程地址空间各个段存放什么数据？

9. 进程通信。。。（说了信号量、管道等，还不够，忘了，说了解线程通信）

10. 进程和线程区别，为什么需要线程，好处是什么？（不知道，举了qq的例子。。。最终目的说了为了提高效率。。。）

11. 线程死锁、解决方式，着重问了”有序分配资源“，进程有序还是资源有序，都可

12. 数据库事务相关，场景：多线程访问数据库脏数据，  （完全不会。。。 用锁保证安全）

13. 场景：1亿条访问记录存磁盘，问如何找到访问最多topk个

    。。。。红黑树？  内存不够，无法加入树

    。。。。位图？  什么是位图？

    。。。。快排+topk？     。。。内存不够怎么快排

    答案： 将1亿条数据分块放入内存，分块进行哈希统计次数，通过topk查找最多k条记录

11 算法题： 有序的链表，删除重复的元素 1 2 33 4  ->  124

12 反问： 岗位对c++功底要求？ 答：岗位用c++和前端技术

​				  为什么面试不问c++？ 答：面试的简历可能有java、c++等，对语言不看重，后期快速学习，着重考察基本功

​				  对我不足建议？ 答：os、db、网络系统复习学习
