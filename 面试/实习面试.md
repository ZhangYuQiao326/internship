

![image-20240326203007939](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240326203007939.png)



## 



## 进程管

### 

|      |      |
| ---- | ---- |
|      |      |
|      |      |
|      |      |

# c++

1. **cpp哪些容器是线程安全的**？

   ① 多线程对容器的读取写入操作不安全，存在脏数据

* c++中的容器本身并没有提供线程安全的机制

* 但是在c++11中引入了，mutex、lock_guard、shared_mutex等线程安全的容器，可以用来确保对容器的安全访问

  ② 迭代器失效

* 当前位置insert元素后，位置之后的迭代器失效

  ```cpp
  it = vec.insert(it, 3);
  ```

  

* 当前位置erase后，位置之后的迭代器失效

  ```cpp
  iter = cont.erase(iter); 
  ```

  

* 重新开辟内存后，所有底层迭代器失效

```cpp
创建时reserve()足够的空间
```

对于序列容器和链式容器，可以erase后返回新的迭代器iter，对于关联式容器，map\set等，因为没有返回值，所以需要手动迭代器递增，unordered_map可以返回更新迭代器

```cpp
map.erase(iter++);
```

-----------

2. **map的底层原理**

   map是一种关联性容器，他存储键值对，且每个键唯一，他底层采用的数据结构是红黑树，红黑树是一种自平衡的二叉搜索树，他能保证插入、删除、查找的操作中提供long n的时间复杂度

   --------------

   

3. **红黑树的优势，如何实现，哪些地方用到了**

   map、mutimap、set、mutiset底层使用红黑树

   红黑树的特性： 1 根节点为黑

   ​							2 某一结点为红，则其子节点一定为黑，没有连续的两个红节点

   ​							3 任意节点的简单路径上，黑色节点的数目相同，红黑树的最长路径不超过最短路							径的两倍

   红黑树的插入：

   1 若插入根节点，则为黑色

   2 插入非根节点，为红色，，根据叔叔的颜色进行调整

   ​				①若父节点为黑，则插入完成		

   ​			② 叔叔 和 父亲 为红色，则叔叔和父亲均变黑，爷变红，继续调整爷爷
   
   ​			③父亲为红，叔叔为黑或空，根据情况进行双旋转 + 变色

-------------------



2. **哈希冲突**

哈希表是一种常见的数据结构，他将输入的关键字映射到一块固定大小的数组中，来实现高效的存储和查找，但是，有时候不同的关键字会映射到同一块数组地址中，造成哈希冲突

开放定址法：顺序的查找下一个空闲的位置

链表发：数组中的各个元素称为头节点，对应的值会以链表的形式插入进去，当插入的形式过多，会插入为红黑树

二次哈希：当一个哈希函数冲突时，在使用另一个函数计算

--------



2. **vector什么时候扩充？扩充机制**

   1. vector是一个可动态增长的数组，插入、、resize等操作都会面临增容问题
   2. 最常见的情况是，vs下capacity是按1.5倍增长的，g++是按2倍增长的。但是具体增长多少，是按照需求定义的，比如我之前阅读过facebook内部使用的fbvecor，他的容量增加策略是：

   * 初始化的时候给8个字节，若装不下一个类型，就给他分配一个类型的空间大小

   * 增长策略是：当现有容量小于或者大于一个临界值时，按照二倍增长
   * 介于给定值中间时候，按照1.5倍增加，并额外给出0.5个空间作为缓冲区

   3. 除此之外，扩容的过程中也会有很多问题，比如说

   * 迭代器失效，我们需要在扩容操作后，返回更新后的迭代器
   * 浅拷贝问题，在开辟新空间后赋值值，若采用内存处理函数memcpy进行拷贝，若vector存储有指针类型，则会导致浅拷贝，因此我们采用元素赋值的方法，调用元素的operator=进行深拷贝

3. **多态原理**

   多态分为两种

   * 编译期间的多态，有函数重载、模板等，==函数重载==的原理是：c++在编译期间根据函数名修饰规则，即根据函数名和参数生成对应的名字放于符号表内
   * 执行期间的多态，即面向对象的特性之一，同一对象的不同行为有多种状态，
   * 多态是==通过虚函数表==实现的，虚函数表内存放的是虚函数的地址，虚基类先生成一张虚函数表，将其拷贝到子类的虚函数表中，表中是基类的虚函数地址，子类重写了虚函数后，将表中的虚函数地址更换
   * 构成多态的==条件==有两个：1 基类通过virtual定义虚函数同一接口，派生类对其实现重写  2 通过基类指针引用调用重写的函数
   * 多态跟实例化对象有关，与调用对象无关
   * 判断是否可以为虚函数？

   | 函数类       | 原理                                      |
   | ------------ | ----------------------------------------- |
   | inline函数   | ❌inline函数没有地址，无法放入虚函数表中   |
   | 静态成员函数 | ❌没有this指针，无法访问到虚基表指针，     |
   | 构造函数     | ❌虚基表是在构造函数的初始化列表开始初始化 |
   | 析构函数     | 基类的析构函数设置为虚函数                |
   |              |                                           |

4. **析构函数为什么设置为虚函数？**

   多态跟实例化的对象有关，与调用的对象无关，当父类指针指向子类对象时,**如果析构函数不是虚函数**,析构就只会释放父类对象,造成内存泄漏。(因为析构重名,只能调用一个,调用默认的父类析构函数)。 **定义成虚函数后**,调用析构时就会取出虚表指针找到实际应该调用的函数。

5. **访问虚函数快还是普通函数快？**

   普通对象：一样快

   传入指针或引用：普通快，因为编译时直接生成地址，虚函数执行时候才生成地址，并且去虚函数表寻找

   ---------

   

6. **容器底层**

| 容器   | 底层                                     | sizeof() |
| ------ | ---------------------------------------- | -------- |
| vector | 三个指针 start 、finish 、end_of_storage | 3 * 4    |



# 

1. **http的长连接和短链接**

​		长连接就是基于tcp的通讯中，一致保持连接，不管当前是否发送和接收数据

短链接是只有数据传参数才进行连接，传输完毕即福安比

1. **epoll多路复用如何实现**
2. **如果恶意http请求过多如何处理**
3. **tcp的流量控制**

![image-20240327144641429](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240327144641429.png)

5. **tcp的拥塞控制**

![image-20240327144508507](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures@main/img/image-20240327144508507.png)



6. **http和https的区别，https的加密算法**

   | http                      | https                                        |
   | ------------------------- | -------------------------------------------- |
   | 传输数据明文、不安全      | http和tcp层之间添加 ssl/tsl协议，加密传输    |
   | 端口90                    | 端口443                                      |
   | tcp三次握手后直接http请求 | tcp三次握手后，还需要ssl tsl握手后，加密传输 |
   |                           | 需要申请数字证书，保证服务器可信             |

   

7. **get和post的区别**

   | GET                                   | POST                                                         |
   | ------------------------------------- | ------------------------------------------------------------ |
   | 幂等（对同一url多次操作返回同样结果） | 非幂等                                                       |
   | get请求被浏览器缓存                   | 不会缓存                                                     |
   | 请求放在url中，不安全                 | 数据放在http包体内，安全                                     |
   | 1个tcp文件（header data）返回200 ok   | 2个tcp（header）先发送，100continue，在发送（data）,返回200ok |
   | 获取数据                              | 修改数据                                                     |



5. **输入1个url显示主页的过程**

   >通过dns域名解析器，获得url对应的ip地址
   >
   >通过三次握手建立tcp连接
   >
   >发送http请求
   >
   >服务器返回html结果
   >
   >发送html内的资源请求，获取css等数据
   >
   >四次挥手关闭tcp连接

   >解析html、渲染

5. **tcp和http的关系**

   一个tcp可以发多个http请求，但是同一时间只能处理一个http请求，

   提高效率：1个tcp顺序处理多个http  2 建立多个tcp

6. 什么是SSL、TLS？

   ssl是安全套接字层，在https与tcp之间，用于加密数据，加密和解密的的钥匙不同，为非对称性加密

7. **TSL的四次握手**

   * 客户端向服务器发送加密请求，包括（客户端支持的TSL版本、1个随机数）
   * 服务器确认版本后，返回（服务器的数字证书、另一个随机数）
   * 客户端检查证书，符合的话从证书里取出（加密公钥，后再次发送随机数
   * 服务器收到第三个随机数后，计算出会话密钥，之后通讯用会话密钥加密

6. **tcp和udp的区别**

   | tcp                                     | udp                                                       |
   | --------------------------------------- | --------------------------------------------------------- |
   | 面向连接、可靠，基于字节流              | 不需要连接、不可靠                                        |
   | 一对一                                  | 一对一 一对多 多对多                                      |
   | 不适用扩充段，是20个字节，头部有消耗    | 8个字节，开销小                                           |
   | 字节流传输，没有边界                    | 按包传送，丢包 乱序                                       |
   | 数据大于mss，在传输层分片，丢片补发该片 | 包大于mtu，会在ip层分片，接收后在ip层组装、再传输给运输层 |
   | 文件传输、http                          | dns、视频音频传输                                         |

   

7. **tcp三次握手、四次挥手**

8. **tcp的粘包和拆包**

   tcp是面向字节流的，没有边界，因此系统在发送tcp时，会通过缓冲区优化

   一次请求发送的数据量过小没达到缓冲区大小，tcp就会将多个请求合并为同一个请求发送

   当一次发送数据超过了缓冲区大小，tcp将其拆分为多个包分多次发送

   解决：

   * 消息定长：发送端将每个包都固定大小，不够可通过补0填充到指定长度
   * 发送端在每个包尾部添加固定的分割符，发生拆包时，等所有包发送完毕后进行合并
   * 消息分为头部和消息体，头部保存整个信息长度，读取到足够长的消息才算完整

# 算法

1. **打印出所有的回文子串**
2. **模拟大数相乘**
3. 判断链表有环
4. 两数之和、三数之和
5. **二分查找、时间复杂度**
6. **topk问题**
7. leetcoe240 搜索二维矩阵

# ios

1. **runtime和runloop**

   runloop负责ios中的事件的监听，每一个线程都对应有一个runloop，main函数自动创建，其余线程需要自己手动打开

   runtime是一套底层的c语言API，负责实现在程序执行的时候动态的调用函数