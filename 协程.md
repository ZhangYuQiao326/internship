[霍丙乾渡劫c++协程](https://www.bennyhuo.com/book/)

# 一 异步线程数据同步

## 1 promise<>

`std::promise<int>`用于存储一个 `int` 类型的值或异常，用于在异步编程中同步数据。

它常与 `std::future<int>` 和 `std::packaged_task<int()>` 一起使用，一个线程通过`std::promise`设置值或异常，另一个线程通过`std::future`获取这个值或等待异常。

需要注意的是，`std::promise`对象只能使用一次来设置值或异常，一旦设置完成，就不能再次设置。

|                 接口                  |                             描述                             |
| :-----------------------------------: | :----------------------------------------------------------: |
|            `get_future()`             | 获取一个与当前`std::promise`对象关联的`std::future`对象。这个`std::future`对象可以用来在其他线程中同步获取`std::promise`所设置的值或异常。 |
|      `set_value(const T& value)`      | 为关联的`std::future`对象设置值。`T`是`std::promise`模板参数指定的类型。调用此函数后，任何等待该`std::future`对象`get()`方法的线程将会收到这个值并继续执行。 |
|        `set_value(T&& value)`         | 以右值引用的方式为关联的`std::future`对象设置值。这是一种移动语义的赋值方式，通常用于优化性能，避免不必要的拷贝操作。 |
| `set_exception(std::exception_ptr p)` | 为关联的`std::future`对象设置异常。`std::exception_ptr`是一个可以持有异常对象的指针。当调用`std::future`的`get()`方法时，如果`std::promise`设置了异常，那么这个异常将被重新抛出。 |



## 2 future<>

|                             接口                             |                             描述                             |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
|                           `get()`                            | 获取与`std::future`对象关联的异步任务的结果。如果结果尚未准备好，该函数将阻塞当前线程，直到结果准备好为止。如果异步任务抛出了异常，`get()`函数将重新抛出该异常。 |
|                           `wait()`                           | 等待与`std::future`对象关联的异步任务完成。该函数将阻塞当前线程，直到异步任务完成。它不返回结果，也不抛出异常，只是简单地等待任务完成。 |
|   `wait_for(std::chrono::duration<Rep, Period> rel_time)`    | 等待与`std::future`对象关联的异步任务完成，但最多只等待指定的相对时间。如果在指定的时间内任务完成，函数将返回`std::future_status::ready`；如果超时但任务未完成，则返回`std::future_status::timeout`；如果任务已被取消或设置了异常，则返回`std::future_status::deferred`。 |
| `wait_until(std::chrono::time_point<Clock, Duration> abs_time)` | 等待与`std::future`对象关联的异步任务完成，但最多只等待到指定的绝对时间点。如果在指定的时间点之前任务完成，函数将返回`std::future_status::ready`；如果超时但任务未完成，则返回`std::future_status::timeout`；如果任务已被取消或设置了异常，则返回`std::future_status::deferred`。 |
|                          `valid()`                           | 检查`std::future`对象是否有效。如果对象是通过有效的`std::promise`对象或`std::async`函数创建的，则返回`true`；否则返回`false`。 |

这些接口提供了对异步任务结果的访问和同步机制。通过`get()`函数，可以获取异步任务的结果；通过`wait()`、`wait_for()`和`wait_until()`函数，可以等待异步任务完成或超时；通过`valid()`函数，可以检查`std::future`对象的有效性。这些接口通常与`std::promise`或`std::async`一起使用，以实现线程间的异步编程和同步机制。

## 3 egg

```cpp
#include <iostream>  
#include <thread>  
#include <future>  
  
void threadFunction(std::promise<int>&& prom) {  
    // 模拟一些工作  
    std::this_thread::sleep_for(std::chrono::seconds(1));  
      
    // 设置 promise 的值  
    prom.set_value(42);  
}  
  
int main() {  
    // 创建一个 promise 对象  
    std::promise<int> prom;  
      
    // 从 promise 对象获取一个 future 对象  
    std::future<int> fut = prom.get_future();  
      
    // 创建一个线程来运行 threadFunction，并将 promise 移动给它  
    std::thread t(threadFunction, std::move(prom));  
      
    // 阻塞，直到 prom.set_value() 被调用
    int value = fut.get(); 
      
    // 输出从 future 获取的值  
    std::cout << "Value: " << value << std::endl;  
      
    // 等待线程完成  
    t.join();  
      
    return 0;  
}
```

# 二 协程

[参考博客](https://zplutor.github.io/2022/03/25/cpp-coroutine-beginner/)

## 1 协程概念

在没有协程的时代，为了应对 IO 操作，主要有三种模型

- **同步编程**：应用程序等待IO结果（比如等待打开一个大的文件，或者等待远端服务器的响应），阻塞当前线程；
- 优点：符合常规思维，易于理解，逻辑简单；
- 缺点：成本高昂，效率太低，其他与IO无关的业务也要等待IO的响应；
- **异步多线程/进程**：将IO操作频繁的逻辑、或者单纯的IO操作独立到一/多个线程中，业务线程与IO线程间靠通信/全局变量来共享数据；
- 优点：充分利用CPU资源，防止阻塞资源
- 缺点：线程切换代价相对较高，异步逻辑代码复杂
- **异步消息+回调函数**：设计一个消息循环处理器，接收外部消息（包括系统通知和网络报文等），收到消息时调用注册的回调函数；
- 优点：充分利用CPU资源，防止阻塞资源
- 缺点：代码逻辑复杂

协程的概念，从一定程度来讲，可以说是**“用同步的语义解决异步问题”**，即业务逻辑看起来是同步的，但实际上并不阻塞当前线程（一般是靠事件循环处理来分发消息）。协程就是用来解决异步逻辑的编程复杂度问题的。

### **优点**

- 协程更加轻量，创建成本更小，降低了内存消耗
- 协程有自己的调度器，减少了 CPU 上下文切换的开销，提高了 CPU 缓存命中率
- 减少同步加锁，整体上提高了性能
- 可以按照同步思维写异步代码，即用同步的逻辑，写由协程调度的回调

### **缺点**

- 在协程执行中不能有阻塞操作，否则整个线程被阻塞
- 协程可以处理 IO 密集型程序的效率问题，但不适合处理 CPU 密集型问题

### **适用场景**

- 高性能计算，牺牲公平性换取吞吐。
- 在 IO 密集型的热舞
- Generator 式的流式计算

协程可以被认为是一种轻量级的线程，但是它们的调度完全由程序员控制，而不是由操作系统内核进行管理。

与线程相比，协程的创建、销毁和切换开销都更小，因此它们更适合于某些特定的异步编程场景。

## 2 协程实现

`普通函数`：停止后，线程函数栈上的数据清空，重新执行函数时候，从头后开始执行

`协程`是一个函数，将线程栈上的数据在堆上保存，停止后，栈上的数据清空，继续执行函数，从堆上获取数据到栈上，实现从停止的位置继续执行

C++20引入关键字 `co_await` 、`co_return` 和 `co_yield`

**只要在普通函数体内使用关键字其中一个，这个函数就会被编译器按照协程编译**

| 关键字      | 作用                                                         |
| ----------- | ------------------------------------------------------------ |
| `co_await`  | 让协程暂停下来（挂起），主线程继续往下执行，协程等待某个操作完成之后再恢复执行 |
| `co_return` | 协程结束，返回协程的执行结果，类似return返回函数结果         |
| `co_yieled` | 多次返回协程的结果，并且让协程暂停，然后等下一次机会恢复执行 |

### 2.1 co_await

* 暂停协程, 执行操作，返回执行结果

* 使用`co_await`需要遵循`awaitable`设计原则，即等待体需要实现三个操作函数
* 作用于对象（等待体），等待体需要实现三个成员函数，顺序调用三个函数

| 函数                       | 功能                                         |
| -------------------------- | -------------------------------------------- |
| `await_ready` ，`返回bool` | `true`:不用暂停  `false`:需要暂停            |
| `await_suspend`，`void`    | 线程执行协程暂停后的操作，执行完毕后唤醒协程 |
| `await_resume`             | 获取暂停后执行操作的结果                     |

```cpp
// 协程
Task PrintInt() {

    IntReader reader1;
    int total = co_await reader1;  // 协程暂停等待操作完成，后唤醒协程，获取操作执行结果

    IntReader reader2;
    total += co_await reader2;
    
    std::cout << total << std::endl;
}
```

```cpp
// 等待体
class IntReader {
public:
    // 判断是否需要暂停协程
    bool await_ready() {
        return false; // 永远暂停
    }

    // co_await暂停时候，自动传入该协程的句柄
    void await_suspend(std::coroutine_handle<> handle) {

        std::thread thread([this, handle]() {

            static int seed = 0;
            value_ = ++seed;

            // 通过句柄唤醒协程
            handle.resume();
            });

        thread.detach();
    }

    // 获取co_await后执行的结果
    int await_resume() {
        return value_;
    }

private:
    int value_{};
};
```

------

* c++20预置两个等待体模型

* 顾名思义，这两个类型分别表示“不暂停”和“要暂停”，实际上它们的区别仅在于 `await_ready()` 函数的返回值， `std::suspend_never` 会返回 true，而 `std::suspend_always` 会返回 false。除此之外，这两个类型的 `await_supsend()` 和 `await_resume()` 函数实现都是空的。

  这两个类型是工具类，用来作为 `promise_type` 部分函数的返回类型，以控制协程在某些时机是否要暂停

| 类型                  | 作用                                    |
| --------------------- | --------------------------------------- |
| `std::suspend_never`  | co_await该awaitable对象，协程永久不挂起 |
| `std::suspend_always` | co_await该awaitable对象，协程永久挂起   |

```cpp
struct suspend_always {
 constexpr bool await_ready() const noexcept { return false; }
 constexpr void await_suspend(std::coroutine_handle<>) const noexcept {}
 constexpr void await_resume() const noexcept {}
 };
```

```cpp
 struct suspend_never {
 constexpr bool await_ready() const noexcept { return true; }
 constexpr void await_suspend(std::coroutine_handle<>) const noexcept {}
 constexpr void await_resume() const noexcept {}
 };
```



### 2.2 co_return

* C++对协程的返回类型只有一个要求：包含名为 `promise_type` 的内嵌类型。
* 当协程被调用，在堆上为其状态分配空间的时候，同时会根据 `promise_type` 类创建出一个`promise`实例化对象。
* 协程的返回值并不是在返回之前才创建，而是在协程的创建出一个`promise`实例化对象建出来之后马上就创建的
* 通过`promise_type`内定义的函数，我们可以与协程进行数据交互，以及控制协程的行为。
* `promise_type`类型规定实现的成员函数

| 函数                    | 作用                                                   |
| ----------------------- | ------------------------------------------------------ |
| `value_`                | 用于保存协程的执行结果                                 |
| `initial_suspend()`     | 协程开始执行时的操作（挂起一会or直接执行）             |
| `get_return_object()`   | 生成协程的返回结果                                     |
| `return_value()`        | 给返回结果赋值，协程结束。调用co_return本质调用该函数  |
| `return_void()`         | 返回空结果                                             |
| `yield_value()`         | 给返回结果赋值,   协程挂起。调用co_yield本质调用该函数 |
| `unhandled_exception()` | 处理异常操作                                           |
| `final_suspend()`       | 协程的结束后执行操作（挂起等待or直接结束释放资源）     |

```cpp
// 自定义协程返回值类型
class Task {
public:
    // ==============================================================
    // 包含规定的内嵌类型，生产promise对象
    class promise_type {
    public:
        promise_type() : value_(std::make_shared<int>()) {}
		// 1 获取协程返回值的对象
        Task get_return_object() { 
            return Task{ value_ };
        }
		
        // 2 协程开始执行时，直接执行，不挂起
        std::suspend_never initial_suspend() { return {}; }
        
        // co_return 10调用
        // 3 给返回值对象赋值10
        void return_value(int value) {
            *value_ = value;
        }
        
        // 4 未定义co_return，则调用返回空
        void return_void() { }
        
        // co_yield调用
        // 5 给返回值对象赋值，返回用就挂机的awaitable对象
        std::suspend_always yield_value(int value) {
            value_ = value;
            return {};
        }
        
        // 6 处理函数异常
        void unhandled_exception() {}

        // 7 协程结束后，直接释放资源，不挂起
        // C++规定 final_suspend() 必须定义成 noexcept ，也就是说它不允许抛出任何异常。
        // 设置挂起后，协程需要通过 coroutine_handle 的 destroy 函数来直接销毁
        std::suspend_never final_suspend() noexcept { return {}; }
private:
        std::shared_ptr<int> value_;
    };
    // ===============================================================

public:
    Task(const std::shared_ptr<int>& value) : value_(value) {}

    int GetValue() const {
        return *value_;
    }

private:
    std::shared_ptr<int> value_;
};

Task GetInt() {

    IntReader reader1;
    int total = co_await reader1;

    IntReader reader2;
    total += co_await reader2;

    co_return total;  // 本质： promise.return_value(total)
}

int main() {
	
    // 执行协程
    auto task = GetInt();

    std::string line;
    while (std::cin >> line) {
        std::cout << task.GetValue() << std::endl;
    }
    return 0;
}
```

### 2.3 co_yield

当协程调用了 `co_return` ，意味着协程结束了，就跟我们在普通函数中用 `return` 结束函数一样。这时候，与这个协程实例有关的内存都会被释放掉，它不能再执行了。如果需要在协程中多次返回数据而不结束协程的话，可以使用 `co_yield` 操作符。

`co_yield` 的作用是，返回一个数据，并且让协程暂停，然后等下一次机会恢复执行。

 `co_yield value` 这个表达式等价于`co_await promise_type.yield_value(value)`

```cpp
#include <coroutine>
#include <iostream>
#include <thread>

// 一、实现三个函数，满足awaitable的规范要求
// 调用co_await会自动调用三个函数
// 存储协程所要执行的功能函数
class IntReader {
public:
    bool await_ready() {
        return false;
    }

    // co_await暂停时候，自动传入该协程的句柄
    void await_suspend(std::coroutine_handle<> handle) {

        std::thread thread([this, handle]() {

            static int seed = 0;
            value_ = ++seed;

            // 通过句柄唤醒协程
            handle.resume();
            });

        thread.detach();
    }

    // 获取co_await后执行的结果
    int await_resume() {
        return value_;
    }

private:
    int value_{};
};

// 二、协程返回值类型：包含名为 promise_type 的内嵌类型
class Task {
public:
    // ================================================================
    class promise_type {
    public:
        // 生成返回结果
        Task get_return_object() {
            return Task{ std::coroutine_handle<promise_type>::from_promise(*this) };
        }

        std::suspend_always yield_value(int value) {
            value_ = value;
            return {};
        }

        // 返回空函数
        void return_void() { }
        std::suspend_never initial_suspend() { return {}; }
        std::suspend_never final_suspend() noexcept { return {}; }
        void unhandled_exception() {}

        // 得到结果
        int GetValue() const {
            return value_;
        }

    private:
        int value_{};
    };
    // ======================================================================

public:
    Task(std::coroutine_handle<promise_type> handle) : coroutine_handle_(handle) {}

    int GetValue() const {
        return coroutine_handle_.promise().GetValue();
    }

    void Next() {
        coroutine_handle_.resume();  // 手动唤醒协程
    }

private:
    // 操作和管理协程
    std::coroutine_handle<promise_type> coroutine_handle_;
};

// 协程
Task GetInt() {

    while (true) {

        IntReader reader;
        int value = co_await reader;
        co_yield value;  // co_await yield_value(value)  
        // 作用1 给task结果赋值value，可以返回结果   
        // 作用2 生成一个永久挂起的awaitable对象，co_await后，一直挂起，等待手动唤醒
    }
}

int main() {

    auto task = GetInt(); // 执行到co_yield挂起

    std::string line;
    while (std::cin >> line) {

        std::cout << task.GetValue() << std::endl;
        task.Next(); // 唤醒协程，继续执行，更新task
    }
    return 0;
}
```



## 3 coroutine_handle

* `std::coroutine_handle<>` 在 C++20 中用于接收一个协程的句柄，操作和管理协程

* 模板参数为promise对象类型，比如：`promise_type`

|              接口函数              |                             描述                             |
| :--------------------------------: | :----------------------------------------------------------: |
|             `resume()`             |      恢复（继续执行）由 `coroutine_handle` 管理的协程。      |
|              `done()`              |          返回一个布尔值，表示协程是否已经完成执行。          |
|            `address()`             |                    返回指向协程帧的指针。                    |
|            `promise()`             | 从句柄获取这个协程的promise对象,可以调用`promise_type`定义的成员函数 |
| `from_promise(promise_t& promise)` |   获取句柄，获取管理该 `promise_t` 的 `coroutine_handle`。   |
|       `from_abi(void* addr)`       | 从 ABI 级别的地址获取 `coroutine_handle`。通常用于底层操作。 |
|            `destroy()`             |           销毁由 `coroutine_handle` 管理的协程帧。           |
|         `operator bool()`          |  返回一个布尔值，表示 `coroutine_handle` 是否有效（非空）。  |
|  `operator*()` 或 `operator->()`   |              解引用操作，用于访问协程帧的成员。              |
| `operator=(coroutine_handle rhs)`  |    赋值操作，将一个 `coroutine_handle` 对象赋值给另一个。    |

请注意，这些接口函数的具体行为可能因 `std::coroutine_handle<>` 模板的参数（即 Promise 类型）而有所不同。在使用时，需要参考具体的 Promise 类型和协程的上下文来理解这些接口函数的确切行为。

```cpp
// 通过handle唤醒协程
handle.resume();

// 获取promise的value
handle.promise.value_;
    
    
```



## 4 promise_type

| 对象      | 功能                                                         |
| --------- | ------------------------------------------------------------ |
| `promise` | 调用协程时，根据`promise_type`自动生成，管理协程的数据，如获取协程结果、管理co_return、co_yield |
| `句柄`    | 由`coroutine_handle<>`获取，唤醒协程、销毁协程、获取promise对象、获取句柄 |

promise_type 是连接协程内外的桥梁

**结果类**需要什么，就通过`promise_type`的`get_return_object()`进行获取

### 4.1 唤醒协程

* 法一：等待体内执行`await_suspend()`后唤醒

```cpp
// 默认获取到本协程的句柄
void await_suspend(std::coroutine_handle<> handle) {
    std::thread thread([this, handle]() {

        static int seed = 0;
        value_ = ++seed;

        // 通过句柄唤醒协程
        handle.resume();
        });
```



* 法二：在结果内中通过句柄进行唤醒

```cpp
class Res{
    class promise_type {
    public:
        // 生成返回结果
        Task get_return_object() {
            // 从promise对象中获取到句柄，作为结果的参数
            return Task{ std::coroutine_handle<promise_type>::from_promise(*this) };
        }
    }
    // ====================
public:
    Res(std::coroutine_handle<promise_type> handle) : coroutine_handle_(handle) {}
private:
    // 通过协程外部的句柄管理协程
    std::coroutine_handle<promise_type> coroutine_handle_;
}
```

### 4.2 销毁协程

#### 4.2.1 co_return

协程调用co_return自动销毁协程，及其句柄

**问题：协程和结果类的生命周期不同，当协程外部存在句柄时候，协程销毁后，句柄失效成为野指针**

#### 4.2.2 句柄管理销毁

```cpp
class Res{
    class promise_type {
    public:
        // 生成返回结果
        Task get_return_object() {
            // 从promise对象中获取到句柄，作为结果的参数
            return Res{ std::coroutine_handle<promise_type>::from_promise(*this) };
        }
        
        // 设置协程执行完毕后，永远挂起，通过句柄销毁
        std::suspend_always final_suspend() noexcept { return {}; }

    }
    // ====================
public:
    Res(std::coroutine_handle<promise_type> handle) : coroutine_handle_(handle) {}
    // 同步生命周期，结果析构，释放协程
    ~Res(){coroutine_handle_.destroy()}
private:
    // 通过协程外部的句柄管理协程
    std::coroutine_handle<promise_type> coroutine_handle_;
}
```

**问题：当结果拷贝时，结果析构一份，释放协程，另外的结果句柄变为野指针**

**修改：禁掉左值拷贝，开放右值拷贝，一个结果对应一个协程**

```cpp
class Res {
  ...

  explicit Res(std::coroutine_handle<promise_type> handle) noexcept
      : handle(handle) {}

  Res(Res &&generator) noexcept
      : handle(std::exchange(generator.handle, {})) {}

  Res(Res &) = delete;
  Generator &operator=(Generator &) = delete;

  ~Res() {
    if (handle) handle.destroy();
  }
}

```





## 5 协程的执行流程

1. 开辟堆空间
2. 栈空间向堆空间拷贝状态信息
3. 创建promise对象
4. 创建协程返回值 `p.get_return_object()`
5. 判断协程执行前是否挂起`p.initial_suspend()`
6. 协程体执行：`co_await()`,`co_suspend()`
7. 协程体结束，调用`co_return`返回结果，通过`p.return_value()`将结果存入promise给外部调用，结束协程
8. 协程体结束，调用`co_return`返回空结果，通过`p.return_void`结束协程
9. co_yield返回结果后挂起
10. 协程结束后判断是否挂起(final_suspend)，否则直接结束，释放资源

![img](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures/img/202404241051077.png)



# 三 异步任务类

## 3.0 同步阻塞、异步回调

![](https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures/img/202405071744392.jpg)

同步阻塞：

**一个任务的执行会阻塞当前线程A的执行，直到线程B任务完成并返回结果。在当前线程A对结果进行处理。**

在这种模型中，程序会按照顺序执行任务，如果其中一个任务需要等待某些操作的完成，那么当前线程会被阻塞，直到这个任务完成并返回结果。

异步回调：

**任务的执行是非阻塞的，当前线程A会继续执行后续代码而不需要等待任务完成。当线程B任务完成后，线程B会调用预先注册的回调函数来处理任务的结果。**

这种模型通常用于处理 I/O 操作、事件处理等需要等待外部资源完成的情况。

## 3.1 promise_type实现 

<img src="https://cdn.jsdelivr.net/gh/ZhangYuQiao326/study_nodes_pictures/img/202405071744392.jpg" alt="33f9f8fbe1d1c3edee38a08fbadd9fb" style="zoom:67%;" />

* 协程返回值Task内的promise_type
* promise的核心函数

| 函数                         | 功能                     |
| ---------------------------- | ------------------------ |
| `private: value / result`    | 存储协程的结果           |
| `return_value()`             | 存储结果到value          |
| `get_value() / get_result()` | promise从value中获取结果 |

```cpp
template<typename ResultType>
struct TaskPromise {
    // 协程立即执行
    std::suspend_never initial_suspend() { return {}; }

    // 执行结束后挂起，等待外部销毁。该逻辑与前面的 Generator 类似
    std::suspend_always final_suspend() noexcept { return {}; }

    // 构造协程的返回值对象 Task,返回协程句柄
    Task<ResultType> get_return_object() {
    return Task{std::coroutine_handle<TaskPromise>::from_promise(*this)};
  	}
    
    // =================================================================
    // 同步阻塞，获取数据
    void return_value(ResultType value) {
        std::lock_guard lock(completion_lock);
        result = Result<ResultType>(std::move(value));
        completion.notify_all();
    }
    
    ResultType get_result() {
        // 如果 result 没有值，说明协程还没有运行完，等待值被写入再返回
        std::unique_lock lock(completion_lock);
        if (!result.has_value()) {
          completion.wait(lock);
    	}
    	// 如果有值，则直接返回（或者抛出异常）
        return result->get_or_throw();
    }

    void unhandled_exception() {
        std::lock_guard lock(completion_lock);
        result = Result<ResultType>(std::current_exception());
        // 通知 get_result 当中的 wait
        completion.notify_all();
    }


private:
    std::optional<Result<ResultType>> result;
    std::mutex completion_lock;
    std::condition_variable completion;
    // =====================================================================
    
    // =====================================================================
    // 异步回调
    void return_value(ResultType value) {
    	std::lock_guard lock(completion_lock);
    	result = Result<ResultType>(std::move(value));
    	completion.notify_all();
        // 调用回调
        notify_callbacks();
  	}
    
    // 判断是否有值，回调处理or注册回调
    void on_completed(std::function<void(Result<ResultType>)> &&func) {
        std::unique_lock lock(completion_lock);
        // 加锁判断 result
        if (result.has_value()) {
          // result 已经有值
          auto value = result.value();
          // 解锁之后再调用 func
          lock.unlock();
          func(value);
        } else {
          // 否则保存回调函数，后续调用
          completion_callbacks.push_back(func);
        }
    }
    
    void unhandled_exception() {
    	std::lock_guard lock(completion_lock);
    	result = Result<ResultType>(std::current_exception());
    	completion.notify_all();
        // 调用回调
        notify_callbacks();
  }
private:
    // 列表，保存回调函数
    std::list<std::function<void(Result<ResultType>)>> completion_callbacks;
  
    void notify_callbacks() {
        auto value = result.value();
        for (auto &callback : completion_callbacks) {
        	callback(value);
    	}
    	// 调用完成，清空回调
    	completion_callbacks.clear();
  	}
```

## 3.2 结果类构建

* 结果类负责与外部函数进行数据交互
* 提供的主要函数

| 函数           | 功能                                                         |
| -------------- | ------------------------------------------------------------ |
| `handle`       | 提供访问协程内部的句柄                                       |
| `get_result()` | 同步阻塞，获取结果类里的数据，调用`handle.promise().get_value()`，后进行处理 |
| `then()`       | 提供回调函数，异步处理协程执行结果（获取+处理结果）          |
| `catching`     | 提供回调函数，异步处理协程的异常（获取+处理异常）            |



```cpp
template<typename ResultType>
struct Task {

    // 声明 promise_type 为 TaskPromise 类型
    using promise_type = TaskPromise<ResultType>;

    // 同步阻塞方式获取result内的值
    // 只获取结果
    ResultType get_result() {
    	return handle.promise().get_result();
    }

	// 异步回调方式获取result内的值
    Task &then(std::function<void(ResultType)> &&func) {
        handle.promise().on_completed([func](auto result) {
            try {
                func(result.get_or_throw());
            } catch (std::exception &e) {
                // 忽略异常
            }
        });
        return *this;
    }

Task &catching(std::function<void(std::exception &)> &&func) {
    handle.promise().on_completed([func](auto result) {
        try {
            // 忽略返回值
            result.get_or_throw();
            } catch (std::exception &e) {
                func(e);
            }
        });
        return *this;
    }

Task &finally(std::function<void()> &&func) {
handle.promise().on_completed([func](auto result) { func(); });
return *this;
}

explicit Task(std::coroutine_handle<promise_type> handle) noexcept: handle(handle) {}

Task(Task &&task) noexcept: handle(std::exchange(task.handle, {})) {}

Task(Task &) = delete;

Task &operator=(Task &) = delete;

~Task() {
if (handle) handle.destroy();
}

private:
std::coroutine_handle<promise_type> handle;
};

```

```cpp
void await_suspend(std::coroutine_handle<> handle) noexcept {
    // 当 task 执行完之后调用 resume
    task.finally([handle]() {
      handle.resume();
    });
  }

Task &finally(std::function<void()> &&func) {
    handle.promise().on_completed([func](auto result) { func(); });
    return *this;
  }

// ==================================================================
auto simpleTask = simple_task();
simpleTask.then([](int i) {
	debug("simple task end: ", i);
})
      
Task &then(std::function<void(ResultType)> &&func) {
    handle.promise().on_completed([func](auto result) {
      try {
        func(result.get_or_throw());
      } catch (std::exception &e) {
        // 忽略异常
      }
    });
    return *this;
  }
void on_completed(std::function<void(Result<ResultType>)> &&func) {
    std::unique_lock lock(completion_lock);
    // 加锁判断 result
    if (result.has_value()) {
      // result 已经有值
      auto value = result.value();
      // 解锁之后再调用 func
      lock.unlock();
      func(value);
    } else {
      // 否则添加回调函数，等待调用
      completion_callbacks.push_back(func);
    }
  }
```

